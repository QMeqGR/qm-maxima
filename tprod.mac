/*
;;  Author Eric Majzoub, Department of Physics and Astronomy
;;  University of Missouri, St. Louis
;;  Copyright (C) 2024 Eric Majzoub

;;  This program is free software; you can redistribute it and/or modify 
;;  it under the terms of the GNU General Public License as published by         
;;  the Free Software Foundation; either version 2 of the License, or            
;;  (at your option) any later version.                                  
                                                                                 
;;  This program is distributed in the hope that it will be useful,              
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of               
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                
;;  GNU General Public License for more details.         

;; Quantum mechanics package for Maxima.
*/

/*****************************************************/
/*****************************************************/
/*             tensor product code                   */
/*****************************************************/
/*****************************************************/

load(multiadditive);

/*
The tensor product code here is necessary for dealing with tensor
products of (j,m)-kets in order to do addition of addtion of angular
momentum calculations of Clebsch-Gordan coefficients. -ehm

Note: setting dotscrules:true is necessary for some operations
to work properly.

*/

/***********************************/
/*          simp rules             */
/***********************************/
/* extended tensor product functionality */
/* The form of a tensor product is tpket(k1,k2)
where k1 and k2 are kets */

tpketp(k):= not mapatom(k) and is(inpart(k,0) = 'tpket) $
tpbrap(k):= not mapatom(k) and is(inpart(k,0) = 'tpbra) $

matchdeclare([k1,k2,k3,k4],ketp,[b1,b2],brap,ll,listp,pf,numberp);
matchdeclare([c1,c2,cf1,cf2],all,[cx1,cx2,cf1,cf2],thingp,[k3,k4],ketp);
tellsimpafter( tpket(c1*k1,c2*k2), c1*c2*tpket(k1,k2) );

tellsimp( tpket(0,k2), 0 );
tellsimp( tpket(k1,0), 0 );

/***********************************************/
/*        Function definitions                 */
/***********************************************/
matchdeclare([cx1,cx2],thingp,tpb,tpbrap,tpk,tpketp);
simp:false; tellsimpafter(cx2*tpb . (tpk*cx1), cx2*cx1*(tpb . tpk)); simp:true;
simp:false; tellsimpafter(tpb . tpk, tpbraket_single(tpb,tpk)); simp:true;

flin(x):=x;
declare(flin,linear);

tpbraket(x,y):=block([A1,A2,tmp,listarith:false,dotscrules:true],
    A1: flin(x), A2: flin(y), tmp: expand(A1 . A2),
    tmp);

matchdeclare(tpkb,lambda([x],tpketp(x) or tpbrap(x)));
simp:false; tellsimpafter( dagger( tpkb ), tpdagger(tpkb) ); simp:true;

declare(tpdagger,[additive,linear]);
matchdeclare([cx1,cx2],thingp,[k1,k2],ketp,[b1,b2],brap);
tellsimpafter( tpdagger(cx1*tpket(k1,k2)), conjugate(cx1)*tpbra(dagger(k1),dagger(k2)) );
tellsimpafter( tpdagger(cx1*tpbra(b1,b2)), conjugate(cx1)*tpket(dagger(b1),dagger(b2)) );

tpbraket_single(b,k):=block([R],
    if tpketp(k)=false or tpbrap(b)=false then
      return(disp("Inputs must be a single tpbra and tpket.")),
    R: ( inpart(b,1) . inpart(k,1) )*( inpart(b,2) . inpart(k,2) ),
    R);


declare([J1z,J2z,Jtz,J1sqr,J2sqr,J1p,J2p,Jtp,J1m,J2m,Jtm],[additive,linear]);

matchdeclare([tpk1,tpk2,k],tpketp);
tellsimpafter( J1z(k), tpket( Jz(inpart(k,1)), inpart(k,2) ) );
tellsimpafter( J2z(k), tpket( inpart(k,1), Jz(inpart(k,2)) ) );
tellsimpafter( Jtz(k), J1z(k) + J2z(k) );

tellsimpafter( J1sqr(k), tpket( Jsqr(inpart(k,1)),inpart(k,2)) );
tellsimpafter( J2sqr(k), tpket( inpart(k,1), Jsqr(inpart(k,2))) );

tellsimpafter( J1p(k), tpket( Jp(inpart(k,1)),inpart(k,2)) );
tellsimpafter( J2p(k), tpket( inpart(k,1),Jp(inpart(k,2))) );
tellsimpafter( Jtp(k), J1p(k) + J2p(k) );

tellsimpafter( J1m(k), tpket( Jm(inpart(k,1)),inpart(k,2)) );
tellsimpafter( J2m(k), tpket( inpart(k,1),Jm(inpart(k,2))) );
tellsimpafter( Jtm(k), J1m(k) + J2m(k) );


declare([J1p2m,J1m2p,J1zJ2z,Jtsqr],[additive,linear]);
J1p2m(k):= block([R,a1,a2,dotscrules:true],
    if tpketp(k)=false then return(false),
    a1:Jp(inpart(k,1)), a2:Jm(inpart(k,2)),
    R: tpket(a1,a2),
    if a1=0 or a2=0 then return(0),
    R);
J1m2p(k):= block([R,a1,a2],
    if tpketp(k)=false then return(false),
    a1:Jm( inpart(k,1)), a2:Jp(inpart(k,2)),
    R: tpket(a1,a2),
    if a1=0 or a2=0 then return(0),
    R);

J1zJ2z(k):= block([R,a1,a2],
    if tpketp(k)=false then return(false),
    a1:Jz( inpart(k,1)), a2:Jz(inpart(k,2)),
    R: tpket(a1,a2),
    if a1=0 or a2=0 then return(0),
    R);

/* Jtsqr = J1sqr + J2sqr + J1p*J2m + J1m*J2p + 2J1zJ2z */
Jtsqr(k):=block([R,r1,r2], 
    if tpketp(k)=false then return(disp("must enter a tpket")),
    r1: J1sqr(k) + J2sqr(k) + 2*J1zJ2z(k),
    r2: J1p2m(k) + J1m2p(k),
    R: r1+r2,
    R);

get_j(x):=block([out,jval,j],
    if rationalp(x)=false then return(disp("Input must be rational number.")),
    out: solve(j*(j+1)=x,j),
    for i: 1 thru 2 do if rhs(out[i])>0 then jval:out[i],
    jval);

tpexpect(Op,psi):=block([dotscrules:true],tpdagger(psi) . Op. psi);

/* Rules for calculating abstract hamiltonian matrix reps */
matchdeclare(tpk,tpketp);
tellsimpafter(J1z . tpk , J1z(tpk));
tellsimpafter(J2z . tpk , J2z(tpk));
tellsimpafter(Jtz . tpk , Jtz(tpk));
tellsimpafter(J1sqr . tpk , J1sqr(tpk));
tellsimpafter(J2sqr . tpk , J2sqr(tpk));
tellsimpafter(J1p . tpk , J1p(tpk));
tellsimpafter(J2p . tpk , J2p(tpk));
tellsimpafter(Jtp . tpk , Jtp(tpk));
tellsimpafter(J1m . tpk , J1m(tpk));
tellsimpafter(J2m . tpk , J2m(tpk));
tellsimpafter(Jtm . tpk , Jtm(tpk));
tellsimpafter(J1p2m . tpk , J1p2m(tpk));
tellsimpafter(J1m2p . tpk , J1m2p(tpk));
tellsimpafter(J1zJ2z . tpk , J1zJ2z(tpk));
tellsimpafter(Jtsqr . tpk , Jtsqr(tpk));

/* additional rules for cases like J1z . J1z . tpk */
matchdeclare(a,all);
tellsimpafter(J1z . (a*tpk) , a*(J1z . tpk));
tellsimpafter(J2z . (a*tpk) , a*(J2z . tpk));
tellsimpafter(Jtz . (a*tpk) , a*(Jtz . tpk));
tellsimpafter(J1sqr . (a*tpk) , a*(J1sqr . tpk));
tellsimpafter(J2sqr . (a*tpk) , a*(J2sqr . tpk));
tellsimpafter(J1p . (a*tpk) , a*(J1p . tpk));
tellsimpafter(J2p . (a*tpk) , a*(J2p . tpk));
tellsimpafter(Jtp . (a*tpk) , a*(Jtp . tpk));
tellsimpafter(J1m . (a*tpk) , a*(J1m . tpk));
tellsimpafter(J2m . (a*tpk) , a*(J2m . tpk));
tellsimpafter(Jtm . (a*tpk) , a*(Jtm . tpk));
tellsimpafter(J1p2m . (a*tpk) , a*(J1p2m . tpk));
tellsimpafter(J1m2p . (a*tpk) , a*(J1m2p . tpk));
tellsimpafter(J1zJ2z . (a*tpk) , a*(J1zJ2z . tpk));
tellsimpafter(Jtsqr . (a*tpk) , a*(Jtsqr . tpk));

