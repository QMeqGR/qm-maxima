/*
;;  Author Eric Majzoub, Department of Physics and Astronomy
;;  University of Missouri, St. Louis
;;  Copyright (C) 2025 Eric Majzoub

;;  This program is free software; you can redistribute it and/or modify 
;;  it under the terms of the GNU General Public License as published by         
;;  the Free Software Foundation; either version 2 of the License, or            
;;  (at your option) any later version.                                  
                                                                                 
;;  This program is distributed in the hope that it will be useful,              
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of               
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                
;;  GNU General Public License for more details.         

;; Quantum mechanics package for Maxima.
*/

/* Robert Dodier's code to allow declared objects to move into a sum.
   The objects must be..
   declare(object,distributes_over_sum)
*/
define_opproperty (distributes_over_sum, simplify_distributes_over_sum)$
simplify_distributes_over_sum(e):= 
if not atom (first (e)) then 
    if op (first (e)) = nounify ('sum) then 
        block ([ss: first (e)], 
        apply(op(ss),
            cons(op(e)(first(ss)),rest(args(ss))))) 
    else e
else e$

/* make sure that dagger and conjugate will distribute over sums */
declare([dagger,conjugate], distributes_over_sum);

/* tellsimp rule to bring the dot operator and kets or bras inside a sum */
matchdeclare (kb, lambda([x], ketp(x) or brap(x) ),
    ss, lambda ([e], not mapatom(e) and (op(e) = 'sum or op(e) = nounify('sum))))$
tellsimp (kb . ss, apply (op(ss), cons ( kb . first(ss), rest(args(ss)))))$

/* combining nested sums */
matchdeclare(kb, lambda([x], ketp(x) or brap(x) , H, qopp));
matchdeclare([ss1,ss2], lambda ([e], not mapatom(e) and (op(e) = 'sum or op(e) = nounify('sum))))$
simp:false;
tellsimp( ss1 . ss2, apply( op(ss1), cons( apply( op(ss2),
        cons( first(ss1) . first(ss2), rest(args(ss1))) ), rest(args(ss2)))))$
simp:true;

/**************************************************************/
/* Define quantum operators (qops and eigenops) as a property */
/**************************************************************/
/* To use this you must... "put(H,qop,qop);" */
qopp(e):= not freeof(e,propvars(qop)) $
eigenopp(e):= not freeof(e,propvars(eigenop)) $
matchdeclare( qq, qopp )$
tellsimp (qq . ss, apply (op(ss), cons ( qq . first(ss), rest(args(ss)))))$

/* Kron-delta evaluation inside a sum */
matchdeclare(skd, lambda ([e], (not mapatom(e) and (op(e) = 'sum or op(e) = nounify('sum)))
        and freeof(kron_delta, inpart(ss,1))=false ))$
matchdeclare(aa, true, krons, lambda([e], freeof(kron_delta,e)=false ) );
matchdeclare(ii,symbolp, [ll,ul],true);
simp:false;
tellsimpafter( 'sum(aa*krons,ii,ll,ul) , skd_reduce(aa*krons,ii,ll,ul) );
simp:true;
skd_reduce(kernel,smidx,ll,ul):=block([i,idx1,idx2],
    for i: 1 thru length(kernel) do
        (if freeof(kron_delta, inpart(kernel,i))=false then
            (idx1:inpart(kernel,i,1), idx2:inpart(kernel,i,2)) ),
    if idx1=smidx then return (subst(idx2,smidx,kernel)) else return (subst(idx1,smidx,kernel))
)$

/* More rules to simplify qops */
/* define 'things' that are not qops or kets or bras */
thingp(x):=is(not qopp(x) and not eigenopp(x) and not ketp(x) and not brap(x) );
matchdeclare(kk,ketp, bb,brap, H, qopp)$
matchdeclare(thing, thingp);
tellsimpafter(bb . H . (thing*kk) , thing* bb . H . kk )$
tellsimpafter(bb . H . (kk*thing) , thing* bb . H . kk )$

/* Energy eigenstate rules */
matchdeclare(H, qopp, HH, eigenopp, thing,thingp );
matchdeclare(eket, lambda([x], ketp(x)=true and (symbolp(inpart(x,1,1)) or integerp(inpart(x,1,1))) ) )$
matchdeclare(ebra, lambda([x], brap(x)=true and (symbolp(inpart(x,1,1)) or integerp(inpart(x,1,1))) ) )$
simp:false; tellsimpafter(HH . eket, E[inpart(eket,1,1)] * eket); simp:true;
simp:false; tellsimpafter(HH . (eket*thing), thing* E[inpart(eket,1,1)] * eket); simp:true;

/* Display matrix element if H=qop but not eigenop */
tellsimpafter(ebra . H . eket, H[inpart(ebra,1,1),inpart(eket,1,1)]);
/* This looks awkward with a comma in the subscript but concatenating
the indices together breaks the indices as something to be summed over
and Maxima pulls the whole matrix element out of the sum. */

/**************************************************************/
/* did this to get time-independent pert theory calcs to work */

/* If E is declared scalar, then E[i] for any i will be scalarp2 */
scalarp2(x):=block(
    if symbolp(x) then return(scalarp(x)) else
    return( not freeof(scalar, apply('properties,[inpart(x,0)])) ) )$

matchdeclare([sc1,sc2,sc3],scalarp2,[s1,s2],scalarp,kk,ketp,bb,brap,aa,true)$
matchdeclare(qq,qopp)$
tellsimpafter( bb . sc1 . kk, sc1* bb . kk)$
tellsimpafter( bb . sc1 . (kk * sc2), sc1*sc2* bb . kk)$
tellsimpafter( bb . s1 . aa, s1* bb . aa)$ /* this seems like it should be in qm.mac */
tellsimpafter( bb . (s1*qq). aa, s1* bb . qq . aa)$

matchdeclare(kk,ketp,bb,brap,[sc1,sc2,sc3], thingp )$
matchdeclare (kb, lambda([x], ketp(x) or brap(x)), qq, qopp,
    ss, lambda ([e], not mapatom(e) and (op(e) = 'sum or op(e) = nounify('sum))))$

tellsimpafter(kb . qq . sc1* ss, apply (op(ss), cons ( sc1*kb . qq . first(ss), rest(args(ss)))))$
tellsimp ((sc1*qq) . ss, apply (op(ss), cons (sc1*qq . first(ss), rest(args(ss)))))$
tellsimp (kb . (sc1*ss), apply (op(ss), cons (sc1*kb . first(ss), rest(args(ss)))))$
simp:false;
tellsimp(bb . (sc1*sc2) . (sc3*kk), sc1*sc2*sc3* bb.kk)$
simp:true;

/******************************************/
/* rules for an eigenop in an exponential */
/******************************************/
matchdeclare(H,qopp,He,eigenopp,[t1,t2],thingp,
    ii,lambda([x], integerp(x) or symbolp(x) ) )$
tellsimpafter(exp(He*t1) . (ket([ii])*t2), exp(E[ii]*t1) * (ket([ii])*t2))$

/* define a new time evolution operator for eigenops */
Uop(H,t):=block(
  if get(H,eigenop)#eigenop then print("warn: operator is not an eigenop!"),
  exp(-%i*H*t/hbar)
)$

/*********************/
/* Utility functions */
/*********************/
declare_qop(x):=put(x,qop,qop);
declare_eigenop(x):=(put(x,qop,qop),put(x,eigenop,eigenop));

/* args: (c,idx,UL,t), first two are mandadory */
psisum([u]):= block([parm:0],
    L:length(u),
    if L>=2 then (cc:u[1], idx:u[2], ul:N, apply('declare,[cc,complex])),
    if L>=3 then (UL:u[3]),
    if L=4  then (parm:u[4], apply('depends,[cc,parm])),
    if L=2  then return
        (subst([I=idx,c=cc],sum(c[I]*ket([I]),I,1,N))),
    if L=3 then return
        (subst([I=idx,c=cc,ul=UL],sum(c[I]*ket([I]),I,1,ul))),
    if L=4 then return
        (subst([I=idx,c=cc,ul=UL,tt=parm],sum(c[I](tt)*ket([I]),I,1,ul))) )$
