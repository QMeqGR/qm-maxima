/*
;;  Author Eric Majzoub, Department of Physics and Astronomy
;;  University of Missouri, St. Louis
;;  Copyright (C) 2025 Eric Majzoub

;;  This program is free software; you can redistribute it and/or modify 
;;  it under the terms of the GNU General Public License as published by         
;;  the Free Software Foundation; either version 2 of the License, or            
;;  (at your option) any later version.                                  
                                                                                 
;;  This program is distributed in the hope that it will be useful,              
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of               
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                
;;  GNU General Public License for more details.         

;; Quantum mechanics package for Maxima.
*/

/* Robert Dodier's code to allow declared objects to move into a sum.
   The objects must be..
   declare(object,distributes_over_sum)
*/
define_opproperty (distributes_over_sum, simplify_distributes_over_sum)$
simplify_distributes_over_sum(e):= 
if not atom (first (e)) then 
    if op (first (e)) = nounify ('sum) then 
        block ([ss: first (e)], 
        apply(op(ss),
            cons(op(e)(first(ss)),rest(args(ss))))) 
    else e
else e$

/* make sure that dagger and conjugate will distribute over sums */
declare([dagger,conjugate], distributes_over_sum);

/* tellsimp rule to bring the dot operator and kets or bras inside a sum */
matchdeclare (kb, lambda([x], ketp(x) or brap(x) ),
    ss, lambda ([e], not mapatom(e) and (op(e) = 'sum or op(e) = nounify('sum))))$
tellsimp (kb . ss, apply (op(ss), cons ( kb . first(ss), rest(args(ss)))))$

/* combining nested sums */
matchdeclare(kb, lambda([x], ketp(x) or brap(x) , H, qopp));
matchdeclare([ss1,ss2], lambda ([e], not mapatom(e) and (op(e) = 'sum or op(e) = nounify('sum))))$
simp:false;
tellsimp( ss1 . ss2, apply( op(ss1), cons( apply( op(ss2),
        cons( first(ss1) . first(ss2), rest(args(ss1))) ), rest(args(ss2)))))$
simp:true;

/* Define quantum operators (qops and eigenops) as a property */
/* To use this you must... "put(H,qop,qop);" */
qopp(e):= not freeof(e,propvars(qop)) $
eigenopp(e):= not freeof(e,propvars(eigenop)) $
matchdeclare( qq, qopp )$
tellsimp (qq . ss, apply (op(ss), cons ( qq . first(ss), rest(args(ss)))))$

/* Kron-delta evaluation inside a sum */
matchdeclare(skd, lambda ([e], (not mapatom(e) and (op(e) = 'sum or op(e) = nounify('sum)))
        and freeof(kron_delta, inpart(ss,1))=false ))$
matchdeclare(aa, true, krons, lambda([e], freeof(kron_delta,e)=false ) );
matchdeclare(ii,symbolp, [ll,ul],true);
simp:false;
tellsimpafter( 'sum(aa*krons,ii,ll,ul) , skd_reduce(aa*krons,ii,ll,ul) );
simp:true;
skd_reduce(kernel,smidx,ll,ul):=block([i,idx1,idx2],
    for i: 1 thru length(kernel) do
        (if freeof(kron_delta, inpart(kernel,i))=false then
            (idx1:inpart(kernel,i,1), idx2:inpart(kernel,i,2)) ),
    if idx1=smidx then return (subst(idx2,smidx,kernel)) else return (subst(idx1,smidx,kernel))
)$

/* More rules to simplify qops */
/* define 'things' that are not qops or kets or bras */
thingp(x):=is(not qopp(x) and not ketp(x) and not brap(x) );
matchdeclare(kk,ketp, bb,brap, H, qopp)$
matchdeclare(thing, thingp);
tellsimpafter(bb . H . (thing*kk) , thing* bb . H . kk )$
tellsimpafter(bb . H . (kk*thing) , thing* bb . H . kk )$

/* Energy eigenstate rules */
matchdeclare(H, qopp, HH, eigenopp, thing,thingp );
matchdeclare(eket, lambda([x], ketp(x)=true and (symbolp(inpart(x,1,1)) or integerp(inpart(x,1,1))) ) )$
matchdeclare(ebra, lambda([x], brap(x)=true and (symbolp(inpart(x,1,1)) or integerp(inpart(x,1,1))) ) )$
simp:false; tellsimpafter(HH . eket, E[inpart(eket,1,1)] * eket); simp:true;
simp:false; tellsimpafter(HH . (eket*thing), thing* E[inpart(eket,1,1)] * eket); simp:true;

/* Display matrix element if H=qop but not eigenop */
tellsimpafter(ebra . H . eket, H[inpart(ebra,1,1),inpart(eket,1,1)]);
/* This looks awkward with a comma in the subscript but concatenating
the indices together breaks the indices as something to be summed over
and Maxima pulls the whole matrix element out of the sum. */

/*********************/
/* Utility functions */
/*********************/
declare_eigenop(x):=put(x,eigenop,eigenop);
declare_qop(x):=put(x,qop,qop);
psisum(cc,idx):= ( apply('declare,[cc,complex]),
  subst([I=idx,c=cc],sum(c[I]*ket([I]),I,1,N)) );

