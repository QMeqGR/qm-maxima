\input texinfo   @c -*-texinfo-*-

@setfilename qm.info
@settitle Package qm

@ifinfo
@macro var {expr}
<\expr\>
@end macro
@end ifinfo

@dircategory Mathematics/Maxima
@direntry
* Package qm: (maxima) Maxima share package qm for quantum mechanics
@end direntry

@menu
* Introduction to package qm::
* Functions and Variables for qm::
@end menu
@node Top, Introduction to package qm, (dir), (dir)
@top

@menu
* Introduction to package qm::
* Functions and Variables for qm::

@detailmenu
 --- The Detailed Node Listing ---

* Introduction to package qm::
* Functions and Variables for qm::

@end detailmenu
@end menu

@chapter Package qm

@node Introduction to package qm, Functions and Variables for qm, Top, Top
@section Introduction to package qm

The @code{qm} package was written by Eric Majzoub, University of
Missouri (email: majzoube-at-umsystem.edu). EM thanks Maxima developers
Robert Dodier and Barton Willis for their contributions that have
improved the package. Please report any errors or unexpected behavior by
submitting an issue on the Github page for this project
(https://github.com/QMeqGR/qm-maxima).

The purpose of this package is to provide computational tools for
solving quantum mechanics problems in a finite-dimensional Hilbert
space. It was written with students in mind as well as practitioners,
and is appropriate for upper-level undergraduate quantum mechanics at
the level of Townsend's @emph{A Modern Introduction to Quantum
Mechanics} and above. Using the package one may compute, for example,
the hyperfine splitting in hydrogen with only a few commands
(@xref{stationary}). Numerous other examples are given throughout the
manual. Additional examples are provided as wxMaxima worksheets in the
@code{doc/examples} folder of the package.

@*
@noindent
The package is loaded with: @code{load(qm);}

@*
@noindent
If you use wxMaxima then issue @code{set_display('ascii);} after
loading the @code{qm} package. This will allow pretty printing of the
kets and bras similar to what you see in this manual.

@subsection Basic capabilities

The @code{qm} package provides functions and standard definitions to
solve quantum mechanics problems in a finite dimensional Hilbert
space. For example, one can calculate the outcome of Stern-Gerlach
experiments using built-in definitions of the Sx, Sy, and Sz operators
for arbitrary spin, e.g. @code{s=@{1/2, 1, 3/2, @dots{}@}}. For spin-1/2
the standard basis kets in the @code{x}, @code{y}, and @code{z}-basis
are defined in the package as @code{@{xp,xm@}}, @code{@{yp,ym@}}, and
@code{@{zp,zm@}}, respectively.

@noindent
Brief list of some capabilities:
@itemize @bullet
@item
Create kets and bras in a matrix representation with arbitrary but
finite dimension.
@item
Create @emph{general} ket vectors with arbitrary but finite dimension.
@item
Given an operator and a state ket, perform standard computations of
expectation values, variance, etc.
@item
For time-independent Hamiltonians one can construct the time evolution
operator and study, for example, magnetic resonance.  
@item
Create kets and bras in the angular momentum @var{|j,m>} representation.
@item
Create tensor products of states to represent multi-particle systems.
@item
Compute Clebsch-Gordan coefficients by stepping up and down the ladder
of states constructed using tensor products of @var{|j,m>} kets.
@item
Construct Bell states and compute quantities of interest for entangled
systems such as density matrices.
@item
Perform partial traces over density matrices to compute reduced
density matrices.
@end itemize

Let us begin with the trivial example of a spin-1/2 particle. This will
illustrate how kets and bras in a matrix representation are defined
within the @code{qm} package. A bra vector in the @code{z}-basis may be
written as

@ @ @ @ @ @ @ @ @code{<psi| = a <z+| + b <z-|}.

@noindent
The matrix representation of the bra @code{<psi|} will be represented in
Maxima by the row vector @code{[a b]}, where the basis vectors are

@ @ @ @ @ @ @ @ @code{<z+| = [1 0]}

@noindent
and

@ @ @ @ @ @ @ @ @code{<z-| = [0 1]}.

@noindent
This bra vector can be created in several ways. First, with the
@code{mbra} command

@ @ @ @ @ @ @ @ @code{mbra([a,b])}

@noindent
or by taking the quantum mechanical dagger of the corresponding ket. In
a Maxima session this looks like the following. The basis kets
@code{@{zp,zm@}} are transformed into bras using the @code{dagger}
function.

@example
@group
(%i1) zp; 
                                     [ 1 ]
(%o1)                                [   ]
                                     [ 0 ]
(%i2) zm; 
                                     [ 0 ]
(%o2)                                [   ]
                                     [ 1 ]
@end group
@end example

@example
@group
(%i1) psi_bra:a*dagger(zp)+b*dagger(zm); 
(%o1)                              [ a  b ]
(%i2) dagger(mket([a,b])); 
(%o2)                              [ a  b ]
(%i3) mbra([a,b]); 
(%o3)                              [ a  b ]
@end group
@end example

@subsection Kets and bras: abstract and matrix representations

There are two types of kets and bras available in the @code{qm} package,
the first type is given by a @emph{matrix representation}, as returned
by the functions @code{mbra} and @code{mket}. @code{mket}s are column
vectors and @code{mbra}s are row vectors, and their components are
entered as Maxima @emph{lists} in the @code{mbra} and @code{mket}
functions. The second type of bra or ket is @emph{abstract}; there is no
matrix representation. Abstract bras and kets are entered using the
@code{bra} and @code{ket} functions, while also using Maxima lists for
the elements. These general kets are displayed in Dirac
notation. Abstract bras and kets are used for both the @code{(j,m)}
representation of states and also for tensor products. For example, a
tensor product of two ket vectors @code{|a>} and @code{|b>} is input as
@code{ket([a,b])} and displayed as

@ @ @ @ @ @ @ @ @code{|a,b>} @ @ @ @ @ (general ket)

@noindent
Note that abstract kets and bras are @emph{assumed to be
orthonormal}. These general bras and kets may be used to build
arbitrarily large tensor product states.

The following examples illustrate some of the basic capabilities of the
@code{qm} package. Here both abstract, and concrete (matrix
representation) kets are shown. The last example shows how to construct
an entangled Bell pair.

@example
@group
(%i1) ket([a,b])+ket([c,d]); 
(%o1)                           |c, d> + |a, b>
(%i2) mket([a,b]); 
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) mbra([a,b]); 
(%o3)                              [ a  b ]
(%i4) bell:(1/sqrt(2))*(ket([u,d])-ket([d,u])); 
                                |u, d> - |d, u>
(%o4)                           ---------------
                                    sqrt(2)
(%i5) dagger(bell); 
                                <u, d| - <d, u|
(%o5)                           ---------------
                                    sqrt(2)
@end group
@end example

Note that @code{ket([a,b])} is treated as tensor product of states
@code{a} and @code{b} as shown below.

@example
@group
(%i1) braket(bra([a1,b1]),ket([a2,b2])); 
(%o1)                kron_delta(a1, a2) kron_delta(b1, b2)
@end group
@end example

Constants that multiply kets and bras must be declared complex by
the user in order for the dagger function to properly conjugate
such constants. The example below illustrates this behavior.

@example
@group
(%i1) declare([a,b],complex); 
(%o1)                                done
(%i2) psi:a*ket([1])+b*ket([2]); 
(%o2)                            |2> b + |1> a
(%i3) psidag:dagger(psi); 
(%o3)                 <2| conjugate(b) + <1| conjugate(a)
(%i4) psidag . psi; 
(%o4)                   b conjugate(b) + a conjugate(a)
@end group
@end example

The following shows how to declare a ket with both real and
complex components in the matrix representation.

@example
@group
(%i1) declare([c1,c2],complex,r,real); 
(%o1)                                done
(%i2) k:mket([c1,c2,r]); 
                                    [ c1 ]
                                    [    ]
(%o2)                               [ c2 ]
                                    [    ]
                                    [ r  ]
(%i3) b:dagger(k); 
(%o3)                 [ conjugate(c1)  conjugate(c2)  r ]
(%i4) b . k; 
                    2
(%o4)              r  + c2 conjugate(c2) + c1 conjugate(c1)
@end group
@end example

@subsection Special ket types

Some kets are difficult to work with using either the matrix
representation or the general ket representation. These include tensor
products of (j,m) kets used in the addition of angular momentum
computations. For this reason there are a set of @code{tpket}s and
associated @code{tpXX} functions defined in section @code{(j,m)-kets and
bras}.

@subsection Basis sets

As described above there are three basis ket types: mkets that have a
matrix representation, abstract kets that are displayed in Dirac
notation, and tensor product kets. Each of the three kets types can be
used to construct a basis set. Valid basis sets are simply Maxima lists
whose elements are one of the three ket types.

@ @ @ @ @ @ @ @ [b@sub{1}, b@sub{2}, b@sub{3}, @dots{} ]

@noindent
Basis sets may be generated automatically using the @code{basis_set}
shown in @xref{basis_set}.

@subsection Types of spin operators: Jxx and Sxx operators

When working with kets and bras in the matrix representation, use the
spin operators @code{Sxx}. When working with abstract kets and bras in
the (j,m) representation use the operators @code{Jxx}. The family of
@code{Sxx} operators are represented as matrices in Maxima, while the
family of @code{Jxx} operators are rule based or function based.

@subsection The dot operator in Maxima

The dot operator ``.'' in Maxima is used for non-commutative
multiplication. In the @code{qm} package the dot operator is
used in the representation of dyads, for example:

@ @ @ @ @ @ @ @code{|a> . <b|}

@noindent
where @code{|a>} and @code{|b>} are arbitrary kets, and to represent
brakets, with

@ @ @ @ @ @ @ @code{<b| . |a> = <b|a>}.

@noindent
There are two important flags that control how Maxima treats the dot
operator that are relevant to the @code{qm} package: @code{dotscrules}
and @code{dotconstrules}. The first allows declared scalar multipliers
to move past the dot operator, while the second allows declared
constants to move past the dot operator. An example where this must be
done is the following, where we use the completeness relation for the
basis set given by the kets @code{|0>} and @code{|1>}. Only the last
line is correctly evaluated, and required declaring @code{a} and
@code{b} to be scalar, and setting @code{dotscrules} to @code{true}.

@example
@group
(%i1) V:complete(basis_set(1,[0,1])); 
(%o1)                        |1> . <1| + |0> . <0|
(%i2) psi:a*ket([0])+b*ket([1]); 
(%o2)                            |1> b + |0> a
(%i3) V . psi; 
(%o3)                          |1> . b + |0> . a
(%i4) declare([a,b],scalar); 
(%o4)                                done
(%i5) V . psi; 
(%o5)                          |1> . b + |0> . a
(%i6) dotscrules:true; 
(%o6)                                true
(%i7) V . psi; 
(%o7)                            |1> b + |0> a
@end group
@end example

@node Functions and Variables for qm, , Introduction to package qm, Top
@section Functions and Variables for qm

@anchor{hbar}
@defvr {Variable} hbar
Planck's constant divided by @code{2*%pi}. @code{hbar} is not given a
floating point value, but is declared to be a real number greater than
zero. If the system variable @code{display2d_unicode} is @code{true} then
@code{hbar} will be displayed as its Unicode character.
@end defvr

@anchor{ket}
@deffn {Function} ket ([@code{k@sub{1}},@code{k@sub{2}},@dots{}])
@code{ket} creates a general state ket, or tensor product, with symbols
@code{k@sub{i}} representing the states. The state kets @code{k@sub{i}}
are assumed to be orthonormal.
@end deffn

@example
@group
(%i1) k:ket([u,d]); 
(%o1)                               |u, d>
(%i2) b:bra([u,d]); 
(%o2)                               <u, d|
(%i3) b . k; 
(%o3)                                  1
@end group
@end example

@anchor{ketp}
@deffn {Function} ketp (abstract ket)
@code{ketp} is a predicate function for abstract kets. It returns
@code{true} for abstract @code{ket}s and @code{false} for anything else.
@end deffn

@anchor{bra}
@deffn {Function} bra ([@code{b@sub{1}},@code{b@sub{2}},@dots{}])
@code{bra} creates a general state bra, or tensor product, with symbols
@code{b@sub{i}} representing the states. The state bras @code{b@sub{i}}
are assumed to be orthonormal.
@end deffn

@example
@group
(%i1) k:ket([u,d]); 
(%o1)                               |u, d>
(%i2) b:bra([u,d]); 
(%o2)                               <u, d|
(%i3) b . k; 
(%o3)                                  1
@end group
@end example

@anchor{brap}
@deffn {Function} brap (abstract bra)
@code{brap} is a predicate function for abstract bras. It returns
@code{true} for abstract @code{bra}s and @code{false} for anything else.
@end deffn

@anchor{mket}
@deffn {Function} mket ([@code{c@sub{1}},@code{c@sub{2}},@dots{}])
@code{mket} creates a @emph{column} vector of arbitrary finite
dimension. The entries @code{c@sub{i}} can be any Maxima expression.
The user must @code{declare} any relevant constants to be complex. For a
matrix representation the elements must be entered as a list in
@code{[@dots{}]} square brackets.
@end deffn

@example
@group
(%i1) declare([c1,c2],complex); 
(%o1)                                done
(%i2) mket([c1,c2]); 
                                    [ c1 ]
(%o2)                               [    ]
                                    [ c2 ]
(%i3) properties(c1); 
(%o3)          [database info, kind(c1, complex), matchdeclare]
@end group
@end example

@anchor{mketp}
@deffn {Function} mketp (@emph{ket})
@code{mketp} is a predicate function that checks if its input is an mket,
in which case it returns @code{true}, else it returns @code{false}.
@code{mketp} only returns @code{true} for the matrix representation of a ket.
@end deffn

@example
@group
(%i1) k:ket([a,b]); 
(%o1)                               |a, b>
(%i2) mketp(k); 
(%o2)                                false
(%i3) k:mket([a,b]); 
                                     [ a ]
(%o3)                                [   ]
                                     [ b ]
(%i4) mketp(k); 
(%o4)                                true
@end group
@end example

@anchor{mbra}
@deffn {Function} mbra ([@code{c@sub{1}},@code{c@sub{2}},@dots{}])
@code{mbra} creates a @emph{row} vector of arbitrary finite
dimension. The entries @code{c@sub{i}} can be any Maxima expression.
The user must @code{declare} any relevant constants to be complex.
For a matrix representation the elements must be entered as a list
in @code{[@dots{}]} square brackets.
@end deffn

@example
@group
(%i1) kill(c1,c2); 
(%o1)                                done
(%i2) mbra([c1,c2]); 
(%o2)                             [ c1  c2 ]
(%i3) properties(c1); 
(%o3)                                 []
@end group
@end example

@anchor{mbrap}
@deffn {Function} mbrap (@emph{bra})
@code{mbrap} is a predicate function that checks if its input is an mbra,
in which case it returns @code{true}, else it returns @code{false}.
@code{mbrap} only returns @code{true} for the matrix representation of a bra.
@end deffn

@example
@group
(%i1) b:mbra([a,b]); 
(%o1)                              [ a  b ]
(%i2) mbrap(b); 
(%o2)                                true
@end group
@end example

Two additional functions are provided to create kets and bras in the
matrix representation. These functions conveniently attempt to
automatically @code{declare} constants as complex. For example, if a
list entry is @code{a*sin(x)+b*cos(x)} then only @code{a} and @code{b}
will be @code{declare}-d complex and not @code{x}.

@anchor{autoket}
@deffn {Function} autoket ([@code{a@sub{1},a@sub{2},@dots{}}])
@code{autoket} takes a list [@code{a@sub{1},a@sub{2},@dots{}}] and
returns a ket with the coefficients @code{a@sub{i}} @code{declare}-d
complex. Simple expressions such as @code{a*sin(x)+b*cos(x)} are allowed
and will @code{declare} only the coefficients as complex.
@end deffn

@example
@group
(%i1) autoket([a,b]); 
                                     [ a ]
(%o1)                                [   ]
                                     [ b ]
(%i2) properties(a); 
(%o2)           [database info, kind(a, complex), matchdeclare]
@end group
@group
(%i1) autoket([a*sin(x),b*sin(x)]); 
                                 [ a sin(x) ]
(%o1)                            [          ]
                                 [ b sin(x) ]
(%i2) properties(a); 
(%o2)           [database info, kind(a, complex), matchdeclare]
@end group
@end example

@anchor{autobra}
@deffn {Function} autobra ([@code{a@sub{1},a@sub{2},@dots{}}])
@code{autobra} takes a list [@code{a@sub{1},a@sub{2},@dots{}}] and
returns a bra with the coefficients @code{a@sub{i}} @code{declare}-d
complex. Simple expressions such as @code{a*sin(x)+b*cos(x)} are allowed
and will @code{declare} only the coefficients as complex.
@end deffn

@example
@group
(%i1) autobra([a,b]); 
(%o1)                              [ a  b ]
(%i2) properties(a); 
(%o2)           [database info, kind(a, complex), matchdeclare]
@end group
@group
(%i1) autobra([a*sin(x),b]); 
(%o1)                           [ a sin(x)  b ]
(%i2) properties(a); 
(%o2)           [database info, kind(a, complex), matchdeclare]
@end group
@end example

@anchor{mket_basis}
@deffn {Function} mket_basis (@code{n})
@code{mket_basis} takes an integer @code{n} and returns a set of
@code{n} basis vectors of length @code{n} with @code{1} in the
@code{i}@sup{th} location of the @code{i}@sup{th} vector. (This is the
common @emph{z}-basis matrix representation for @code{2j+1=n} states.)
@end deffn

@example
@group
(%i1) mket_basis(2); 
                                 [ 1 ]  [ 0 ]
(%o1)                           [[   ], [   ]]
                                 [ 0 ]  [ 1 ]
@end group
@end example

@anchor{dagger}
@deffn {Function} dagger (@emph{vector})
@code{dagger} is the quantum mechanical @emph{dagger} function and returns
the @code{conjugate} @code{transpose} of its input. Arbitrary constants
must be @code{declare}-d complex for dagger to produce the conjugate.
@end deffn

@example
@group
(%i1) dagger(mbra([%i,2])); 
                                   [ - %i ]
(%o1)                              [      ]
                                   [  2   ]
@end group
@end example

@anchor{braket}
@deffn {Function} braket (@code{psi,phi})
Given a bra @code{psi} and ket @code{phi}, @code{braket} returns the
quantum mechanical bracket @code{<psi|phi>}. Note, @code{braket(b,k)} is
equivalent to @code{b . k} where @code{.} is the Maxima non-commutative
@code{dot} operator.
@end deffn

@example
@group
(%i1) declare([a,b,c],complex); 
(%o1)                                done
(%i2) braket(mbra([a,b,c]),mket([a,b,c])); 
                                  2    2    2
(%o2)                            c  + b  + a
(%i3) braket(dagger(mket([a,b,c])),mket([a,b,c])); 
(%o3)          c conjugate(c) + b conjugate(b) + a conjugate(a)
(%i4) braket(bra([a1,b1,c1]),ket([a2,b2,c2])); 
(%o4)      kron_delta(a1, a2) kron_delta(b1, b2) kron_delta(c1, c2)
@end group
@end example

@anchor{norm}
@deffn {Function} norm (@code{psi})
Given a @code{ket} or @code{bra} @code{psi}, @code{norm} returns the
square root of the quantum mechanical bracket @code{<psi|psi>}.
The vector @code{psi} must always be a @code{ket}, otherwise the
function will return @code{false}.
@end deffn

@example
@group
(%i1) declare([a,b,c],complex); 
(%o1)                                done
(%i2) norm(mket([a,b,c])); 
(%o2)       sqrt(c conjugate(c) + b conjugate(b) + a conjugate(a))
@end group
@end example

@anchor{magsqr}
@deffn {Function} magsqr (@code{c})
@code{magsqr} returns @code{conjugate(c)*c}, the magnitude
squared of a complex number.
@end deffn

@example
@group
(%i1) declare([a,b,c,d],complex); 
(%o1)                                done
(%i2) braket(mbra([a,b]),mket([c,d])); 
(%o2)                              b d + a c
(%i3) P:magsqr(%); 
(%o3) (b d + a c) (conjugate(b) conjugate(d) + conjugate(a) conjugate(c))
@end group
@end example

@subsection Spin-1/2 state kets and associated operators

Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states. It is spanned by two vectors. In the @var{z}-basis
these vectors are @code{@{zp,zm@}}, and the basis kets in the
@var{z}-basis are @code{@{xp,xm@}} and @code{@{yp,ym@}} respectively.

@anchor{zp}
@deffn {Function} zp
Return the @var{|z+>} ket in the @var{z}-basis.
@end deffn

@anchor{zm}
@deffn {Function} zm
Return the @var{|z->} ket in the @var{z}-basis.
@end deffn

@anchor{xp}
@deffn {Function} xp
Return the @var{|x+>} ket in the @var{z}-basis.
@end deffn

@anchor{xm}
@deffn {Function} xm
Return the @var{|x->} ket in the @var{z}-basis.
@end deffn

@anchor{yp}
@deffn {Function} yp
Return the @var{|y+>} ket in the @var{z}-basis.
@end deffn

@anchor{ym}
@deffn {Function} ym
Return the @var{|y->} ket in the @var{z}-basis.
@end deffn


@example
@group
(%i1) yp; 
                                  [    1    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%o1)                             [         ]
                                  [   %i    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%i2) ym; 
                                 [     1     ]
                                 [  -------  ]
                                 [  sqrt(2)  ]
(%o2)                            [           ]
                                 [     %i    ]
                                 [ - ------- ]
                                 [   sqrt(2) ]
@end group
@group
(%i1) braket(dagger(xp),zp); 
                                       1
(%o1)                               -------
                                    sqrt(2)
@end group
@end example

Switching bases is done in the following example where a @var{z}-basis
ket is constructed and the @var{x}-basis ket is computed.

@example
@group
(%i1) declare([a,b],complex); 
(%o1)                                done
(%i2) psi:mket([a,b]); 
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) psi_x:'xp*braket(dagger(xp),psi)+'xm*braket(dagger(xm),psi); 
                    b         a              a         b
(%o3)           (------- + -------) xp + (------- - -------) xm
                 sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
@end group
@end example

@subsection Pauli matrices and Sz, Sx, Sy operators

@anchor{sigmax}
@deffn {Function} @code{sigmax}
Returns the Pauli @var{x} matrix.
@end deffn

@anchor{sigmay}
@deffn {Function} @code{sigmay}
Returns the Pauli @var{y} matrix.
@end deffn

@anchor{sigmaz}
@deffn {Function} @code{sigmaz}
Returns the Pauli @var{z} matrix.
@end deffn

@anchor{Sx}
@deffn {Function} @code{Sx}
Returns the spin-1/2 @var{Sx} matrix.
@end deffn

@anchor{Sy}
@deffn {Function} @code{Sy}
Returns the spin-1/2 @var{Sy} matrix.
@end deffn

@anchor{Sz}
@deffn {Function} @code{Sz}
Returns the spin-1/2 @var{Sz} matrix.
@end deffn

@example
@group
(%i1) sigmay; 
                                 [ 0   - %i ]
(%o1)                            [          ]
                                 [ %i   0   ]
(%i2) Sy; 
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o2)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
@end group
@end example

@anchor{commutator}
@deffn {Function} commutator (@code{X,Y})
Given two operators @code{X} and @code{Y}, return the
commutator @code{X . Y - Y . X}.
@end deffn

@example
@group
(%i1) commutator(Sx,Sy); 
                           [        2             ]
                           [ %i hbar              ]
                           [ --------      0      ]
                           [    2                 ]
(%o1)                      [                      ]
                           [                    2 ]
                           [             %i hbar  ]
                           [    0      - -------- ]
                           [                2     ]
@end group
@end example

@anchor{anticommutator}
@deffn {Function} anticommutator (@code{X,Y})
Given two operators @code{X} and @code{Y}, return the
commutator @code{X . Y + Y . X}.
@end deffn

@example
@group
(%i1) (1/2)*anticommutator(sigmax,sigmax); 
                                   [ 1  0 ]
(%o1)                              [      ]
                                   [ 0  1 ]
@end group
@end example

@subsection SX, SY, SZ operators for any spin

@anchor{SX}
@deffn {Function} SX (@code{s})
@code{SX(s)} for spin @code{s} returns the matrix representation of the
spin operator @code{Sx}. Shortcuts for spin-1/2 are @code{Sx,Sy,Sz}, and
for spin-1 are @code{Sx1,Sy1,Sz1}.
@end deffn

@anchor{SY}
@deffn {Function} SY (@code{s})
@code{SY(s)} for spin @code{s} returns the matrix representation of the
spin operator @code{Sy}. Shortcuts for spin-1/2 are @code{Sx,Sy,Sz}, and
for spin-1 are @code{Sx1,Sy1,Sz1}.
@end deffn

@anchor{SZ}
@deffn {Function} SZ (@code{s})
@code{SZ(s)} for spin @code{s} returns the matrix representation of the
spin operator @code{Sz}. Shortcuts for spin-1/2 are @code{Sx,Sy,Sz}, and
for spin-1 are @code{Sx1,Sy1,Sz1}.
@end deffn

Example:

@example
@group
(%i1) SY(1/2); 
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o1)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
(%i2) SX(1); 
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
                         [                           ]
                         [  hbar              hbar   ]
(%o2)                    [ -------     0     ------- ]
                         [ sqrt(2)           sqrt(2) ]
                         [                           ]
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
@end group
@end example

@subsection Basis set transformations

Given a matrix representation of an operator in terms of @code{mket}s
one may transform from one @code{mket} basis to another.

@anchor{basis_set_p}
@deffn {Function} basis_set_p (@code{B})
The predicate function @code{basis_set_p} takes as an argument a basis
set @code{[b@sub{1},b@sub{2},@dots{}]} enclosed in square brackets,
where each @code{b@sub{i}} is @code{true} for the predicate function
@code{mketp}.
@end deffn

@example
@group
(%i1) basis_set_p([zp,zm]); 
(%o1)                                true
@end group
@end example

@anchor{mtrans}
@deffn {Function} mtrans (@code{B@sub{1},B@sub{2}})
The function @code{mtrans} returns the matrix of inner products of the
two bases @code{B@sub{1}} and @code{B@sub{2}}. The bases must be of the
same dimension.
@end deffn

@example
@group
(%i1) mtrans([zp,zm],[yp,ym]); 
                            [    1         1     ]
                            [ -------   -------  ]
                            [ sqrt(2)   sqrt(2)  ]
(%o1)                       [                    ]
                            [   %i         %i    ]
                            [ -------  - ------- ]
                            [ sqrt(2)    sqrt(2) ]
@end group
@end example


@anchor{op_trans}
@deffn {Function} op_trans (@code{A,B@sub{1},B@sub{2}})
The function @code{op_trans} returns the matrix representation of
operator @code{A} in basis @code{B@sub{2}}. The operator @code{A} must
be given in the basis @code{B@sub{1}}.
@end deffn

@example
@group
(%i1) op_trans(Sy,[zp,zm],[yp,ym]); 
                               [ hbar         ]
                               [ ----    0    ]
                               [  2           ]
(%o1)                          [              ]
                               [         hbar ]
                               [  0    - ---- ]
                               [          2   ]
@end group
@end example


@subsection Expectation value and variance

@anchor{expect}
@deffn {Function} expect (@code{O,psi})
Computes the quantum mechanical expectation value of the operator @code{O}
in state @code{psi}, @code{<psi|O|psi>}.
@end deffn

@example
@group
(%i1) ev(expect(Sy,xp+ym),ratsimp); 
(%o1)                               - hbar
@end group
@end example

@anchor{qm_variance}
@deffn {Function} qm_variance (@code{O,psi})
Computes the quantum mechanical variance of the operator @code{O}
in state @code{psi}, @code{sqrt(<psi|O@sup{2}|psi> - <psi|O|psi>@sup{2})}.
@end deffn

@example
@group
(%i1) ev(qm_variance(Sy,xp+ym),ratsimp); 
                                    %i hbar
(%o1)                               -------
                                       2
@end group
@end example

@subsection Angular momentum and ladder operators in the matrix representation

@anchor{SP}
@deffn {Function} SP (@code{s})
@code{SP} is the raising ladder operator @var{S@sub{+}} for spin @code{s}.
@end deffn

@anchor{SM}
@deffn {Function} SM (@code{s})
@code{SM} is the raising ladder operator @var{S@sub{-}} for spin @code{s}.
@end deffn

Examples of the ladder operators:

@example
@group
(%i1) SP(1); 
                       [ 0  sqrt(2) hbar       0       ]
                       [                               ]
(%o1)                  [ 0       0        sqrt(2) hbar ]
                       [                               ]
                       [ 0       0             0       ]
(%i2) SM(1); 
                       [      0             0        0 ]
                       [                               ]
(%o2)                  [ sqrt(2) hbar       0        0 ]
                       [                               ]
                       [      0        sqrt(2) hbar  0 ]
@end group
@end example

@subsection Rotation operators

@anchor{RX}
@deffn {Function} RX (@code{s,t})
@code{RX(s)} for spin @code{s} returns the matrix representation of the
rotation operator @code{Rx} for rotation through angle @code{t}.
@end deffn

@anchor{RY}
@deffn {Function} RY (@code{s,t})
@code{RY(s)} for spin @code{s} returns the matrix representation of the
rotation operator @code{Ry} for rotation through angle @code{t}.
@end deffn

@anchor{RZ}
@deffn {Function} RZ (@code{s,t})
@code{RZ(s)} for spin @code{s} returns the matrix representation of the
rotation operator @code{Rz} for rotation through angle @code{t}.
@end deffn

@example
@group
(%i1) RY(1,t); 
                     [ cos(t) + 1    sin(t)   1 - cos(t) ]
                     [ ----------  - -------  ---------- ]
                     [     2         sqrt(2)      2      ]
                     [                                   ]
                     [  sin(t)                  sin(t)   ]
(%o1)                [  -------     cos(t)    - -------  ]
                     [  sqrt(2)                 sqrt(2)  ]
                     [                                   ]
                     [ 1 - cos(t)   sin(t)    cos(t) + 1 ]
                     [ ----------   -------   ---------- ]
                     [     2        sqrt(2)       2      ]
@end group
@end example

@subsection Time-evolution operator

@anchor{U}
@deffn {Function} U (@code{H,t})
@code{U(H,t)} is the time evolution operator for Hamiltonian @code{H}. It
is defined as the matrix exponential @code{matrixexp(-%i*H*t/hbar)}.
@end deffn

@example
@group
(%i1) assume(w > 0); 
(%o1)                               [w > 0]
(%i2) U(w*Sy,t); 
                           [     t w         t w  ]
                           [ cos(---)  - sin(---) ]
                           [      2           2   ]
(%o2)                      [                      ]
                           [     t w        t w   ]
                           [ sin(---)   cos(---)  ]
                           [      2          2    ]
@end group
@end example

@section Angular momentum representation of kets and bras

@subsection Matrix representation of (j,m)-kets and bras

The matrix representation of kets and bras in the @code{qm} package are
represented in the @code{z}-basis. To create a matrix representation of
of a ket or bra in the (j,m)-basis one uses the @code{spin_mket} and
@code{spin_mbra} functions.

@anchor{spin_mket}
@deffn {Function} spin_mket (s,m@sub{s},[1,2,3])
@code{spin_mket} returns a ket in the @code{z}-basis for spin @code{s}
and z-projection @code{m@sub{s}}, for axis 1=X, 2=Y, 3=Z.
@end deffn

@anchor{spin_mbra}
@deffn {Function} spin_mbra (s,m@sub{s},[1,2,3])
@code{spin_mbra} returns a bra in the @code{z}-basis for spin @code{s}
and z-projection @code{m@sub{s}}, for axis 1=X, 2=Y, 3=Z.
@end deffn

@example
@group
(%i1) spin_mbra(3/2,1/2,2); 
                    [ sqrt(3)     %i    1      sqrt(3) %i ]
(%o1)               [ -------  - ----  ----  - ---------- ]
                    [   3/2       3/2   3/2        3/2    ]
                    [  2         2     2          2       ]
@end group
@end example

@subsection Angular momentum (j,m)-kets and bras

To create kets and bras in the @var{|j,m>} representation you use the
abstract @code{ket} and @code{bra} functions with @code{j,m} as
arguments, as in @code{ket([j,m])} and @code{bra([j,m])}.

@example
@group
(%i1) bra([3/2,1/2]); 
                                     3  1
(%o1)                               <-, -|
                                     2  2
(%i2) ket([3/2,1/2]); 
                                     3  1
(%o2)                               |-, ->
                                     2  2
@end group
@end example

Some convenience functions for making the kets are the following:

@anchor{jmtop}
@deffn {Function} jmtop (@code{j})
@code{jmtop} creates a (j,m)-ket with @code{m=j}.
@end deffn

@example
@group
(%i1) jmtop(3/2); 
                                     3  3
(%o1)                               |-, ->
                                     2  2
@end group
@end example

@anchor{jmbot}
@deffn {Function} jmbot (@code{j})
@code{jmbot} creates a (j,m)-ket with @code{m=-j}.
@end deffn

@example
@group
(%i1) jmbot(3/2); 
                                    3    3
(%o1)                              |-, - ->
                                    2    2
@end group
@end example

@anchor{jmket}
@deffn {Function} jmket (@code{j,m})
@code{jmket} creates a (j,m)-ket.
@end deffn

@example
@group
(%i1) jmket(3/2,1/2); 
                                     3  1
(%o1)                               |-, ->
                                     2  2
@end group
@end example

@anchor{jmketp}
@deffn {Function} jmketp (@emph{jmket})
@code{jmketp} checks to see that the ket has an @code{m}-value that is in
the set @code{@{-j,-j+1,@dots{},+j@}}.
@end deffn

@example
@group
(%i1) jmketp(ket([j,m])); 
(%o1)                                false
(%i2) jmketp(ket([3/2,1/2])); 
(%o2)                                true
@end group
@end example

@anchor{jmbrap}
@deffn {Function} jmbrap (@emph{jmbra})
@code{jmbrap} checks to see that the bra has an @code{m}-value that is in
the set @code{@{-j,-j+1,@dots{},+j@}}.
@end deffn

@anchor{jmcheck}
@deffn {Function} jmcheck (@code{j,m})
@code{jmcheck} checks to see that @var{m} is one of @{-j, @dots{}, +j@}.
@end deffn

@example
@group
(%i1) jmcheck(3/2,1/2); 
(%o1)                                true
@end group
@end example

@anchor{Jp}
@deffn {Function} Jp (@emph{jmket})
@code{Jp} is the @code{J@sub{+}} operator. It takes a @code{jmket}
@code{jmket(j,m)} and returns @code{sqrt(j*(j+1)-m*(m+1))*hbar*jmket(j,m+1)}.
@end deffn

@anchor{Jm}
@deffn {Function} Jm (@emph{jmket})
@code{Jm} is the @code{J@sub{-}} operator. It takes a @code{jmket}
@code{jmket(j,m)} and returns @code{sqrt(j*(j+1)-m*(m-1))*hbar*jmket(j,m-1)}.
@end deffn

@anchor{Jsqr}
@deffn {Function} Jsqr (@emph{jmket})
@code{Jsqr} is the @code{J@sup{2}} operator. It takes a @code{jmket}
@code{jmket(j,m)} and returns @code{j*(j+1)*hbar@sup{2}*jmket(j,m)}.
@end deffn

@anchor{Jz}
@deffn {Function} Jz (@emph{jmket})
@code{Jz} is the @code{J@sub{z}} operator. It takes a @code{jmket}
@code{jmket(j,m)} and returns @code{m*hbar*jmket(j,m)}.
@end deffn

These functions are illustrated below.

@example
@group
(%i1) k:ket([j,m]); 
(%o1)                               |j, m>
(%i2) Jp(k); 
(%o2)             hbar |j, m + 1> sqrt(j (j + 1) - m (m + 1))
(%i3) Jm(k); 
(%o3)             hbar |j, m - 1> sqrt(j (j + 1) - (m - 1) m)
(%i4) Jsqr(k); 
                                2
(%o4)                       hbar  j (j + 1) |j, m>
(%i5) Jz(k); 
(%o5)                            hbar |j, m> m
@end group
@end example

@subsection Addition of angular momentum in the (j,m)-representation

Addition of angular momentum calculations can be performed in the
(j,m)-representation using the function definitions below. The internal
representation of kets and bras for this purpose is the following. Given
kets @code{|j1,m1>} and @code{|j2,m2>} a tensor product of (j,m)-kets
is instantiated as:

@ @ @ @ @ @ @ @ @ @ @code{tpket(1,|j1,m1>,|j2,m2>)}

@noindent
and the corresponding bra is instantiated as:

@ @ @ @ @ @ @ @ @ @ @code{tpbra(1,<j1,m1|,<j2,m2|)}

@noindent
where the factor of 1 is the multiplicative factor of the tensor
product. We call this the @emph{common factor} (cf) of the tensor
product. The general form of a tensor product in the (j,m)
representation is:

@ @ @ @ @ @ @ @ @ @ @code{tpket( cf, |j1,m1>, |j2,m2> )}.

@noindent
@anchor{tpket}
@deffn {Function} tpket (@emph{jmket1,jmket2})
@code{tpket} instantiates a tensor product of two (j,m)-kets.
@end deffn

@example
@group
(%i1) tpket(ket([3/2,1/2]),ket([1/2,1/2])); 
                                 3  1     1  1
(%o1)                         1·|-, -> ⨂ |-, ->
                                 2  2     2  2
@end group
@end example

@anchor{tpbra}
@deffn {Function} tpbra (@emph{jmbra1,jmbra2})
@code{tpbra} instantiates a tensor product of two (j,m)-bras.
@end deffn

@example
@group
(%i1) tpbra(bra([3/2,1/2]),bra([1/2,1/2])); 
                                 3  1     1  1
(%o1)                         1·<-, -| ⨂ <-, -|
                                 2  2     2  2
@end group
@end example

@anchor{tpbraket}
@deffn {Function} tpbraket (@emph{tpbra,tpket})
@code{tpbraket} returns the bracket of a @code{tpbra} and a @code{tpket}.
@end deffn

@example
@group
(%i1) k:tpket(jmtop(1),jmbot(1)); 
(%o1)                        1·|1, 1> ⨂ |1, - 1>
(%i2) K:Jtsqr(k); 
                  2                           2
(%o2)       2 hbar ·|1, 1> ⨂ |1, - 1> + 2 hbar ·|1, 0> ⨂ |1, 0>
(%i3) B:tpdagger(k); 
(%o3)                        1·<1, 1| ⨂ <1, - 1|
(%i4) tpbraket(B,K); 
                                          2
(%o4)                               2 hbar
@end group
@end example

@anchor{tpcfset}
@deffn {Function} tpcfset (@code{cf},@emph{tpket})
@code{tpcfset} manually sets the @emph{common factor} @code{cf} of a @code{tpket}.
@end deffn

@anchor{tpscmult}
@deffn {Function} tpscmult (@code{a},@emph{tpket})
@code{tpscmult} multiplies the tensor product's common factor by @code{a}.
Any symbols must be @code{declare}d @code{scalar}.
@end deffn

@example
@group
(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2])); 
                                1  1     1    1
(%o1)                        1·|-, -> ⨂ |-, - ->
                                2  2     2    2
(%i2) declare(c,scalar); 
(%o2)                                done
(%i3) tpscmult(c,k1); 
                                1  1     1    1
(%o3)                        c·|-, -> ⨂ |-, - ->
                                2  2     2    2
@end group
@end example

@anchor{tpadd}
@deffn {Function} tpadd (@emph{tpket,tpket})
@code{tpadd} adds two @code{tpket}s. This function is necessary
to avoid trouble with Maxima's automatic list arithmetic.
@end deffn

@example
@group
(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2])); 
                                1  1     1    1
(%o1)                        1·|-, -> ⨂ |-, - ->
                                2  2     2    2
(%i2) k2:tpket(ket([1/2,-1/2]),ket([1/2,1/2])); 
                                1    1     1  1
(%o2)                        1·|-, - -> ⨂ |-, ->
                                2    2     2  2
(%i3) tpadd(k1,k2); 
                    1  1     1    1       1    1     1  1
(%o3)            1·|-, -> ⨂ |-, - -> + 1·|-, - -> ⨂ |-, ->
                    2  2     2    2       2    2     2  2
@end group
@end example

@anchor{tpdagger}
@deffn {Function} tpdagger (@emph{tpket or tpbra})
@code{tpdagger} takes the quantum mechanical dagger of a @code{tpket} or @code{tpbra}.
@end deffn

@example
@group
(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2])); 
                                1  1     1    1
(%o1)                        1·|-, -> ⨂ |-, - ->
                                2  2     2    2
(%i2) tpdagger(k1); 
                                1  1     1    1
(%o2)                        1·<-, -| ⨂ <-, - -|
                                2  2     2    2
@end group
@end example

@anchor{J1z}
@deffn {Function} J1z (@emph{tpket})
@code{J1z} returns the tensor product of a tpket with @code{Jz} acting
on the first ket.
@end deffn

@anchor{J2z}
@deffn {Function} J2z (@emph{tpket})
@code{J2z} returns the tensor product of a tpket with @code{Jz} acting
on the second ket.
@end deffn

@example
@group
(%i1) k:tpket(ket([3/2,3/2]),ket([1/2,1/2])); 
                                 3  3     1  1
(%o1)                         1·|-, -> ⨂ |-, ->
                                 2  2     2  2
(%i2) J1z(k); 
                           3 hbar  3  3     1  1
(%o2)                      ------·|-, -> ⨂ |-, ->
                             2     2  2     2  2
(%i3) J2z(k); 
                            hbar  3  3     1  1
(%o3)                       ----·|-, -> ⨂ |-, ->
                             2    2  2     2  2
@end group
@end example

@anchor{Jtz}
@deffn {Function} Jtz (@emph{tpket})
@code{Jtz} is the total z-projection of spin operator acting on a tpket
and returning @code{(J@sub{1z}+J@sub{2z})}.
@end deffn

@example
@group
(%i1) k:tpket(ket([3/2,3/2]),ket([1/2,1/2])); 
                                 3  3     1  1
(%o1)                         1·|-, -> ⨂ |-, ->
                                 2  2     2  2
(%i2) Jtz(k); 
                                   3  3     1  1
(%o2)                      2 hbar·|-, -> ⨂ |-, ->
                                   2  2     2  2
@end group
@end example

@anchor{J1sqr}
@deffn {Function} J1sqr (@emph{tpket})
@code{J1sqr} returns @code{Jsqr} for the first ket of a tpket.
@end deffn

@anchor{J2sqr}
@deffn {Function} J2sqr (@emph{tpket})
@code{J2sqr} returns @code{Jsqr} for the second ket of a tpket.
@end deffn

@anchor{J1p}
@deffn {Function} J1p (@emph{tpket})
@code{J1p} returns @code{J@sub{+}} for the first ket of a tpket.
@end deffn

@anchor{J2p}
@deffn {Function} J2p (@emph{tpket})
@code{J2p} returns @code{J@sub{+}} for the second ket of a tpket.
@end deffn

@anchor{Jtp}
@deffn {Function} Jtp (@emph{tpket})
@code{Jtp} returns @code{(J@sub{1+}+J@sub{2+})} for the tpket.
@end deffn

@anchor{J1m}
@deffn {Function} J1m (@emph{tpket})
@code{J1m} returns @code{J@sub{-}} for the first ket of a tpket.
@end deffn

@anchor{J2m}
@deffn {Function} J2m (@emph{tpket})
@code{J2m} returns @code{J@sub{-}} for the second ket of a tpket.
@end deffn

@anchor{Jtm}
@deffn {Function} Jtm (@emph{tpket})
@code{Jtm} returns @code{(J@sub{1-}+J@sub{2-})} for the tpket.
@end deffn

@anchor{J1p2m}
@deffn {Function} J1p2m (@emph{tpket})
@code{J1p2m} returns @code{(J@sub{1+}J@sub{2-})} for the tpket.
@end deffn

@example
@group
(%i1) k:tpket(ket([3/2,1/2]),ket([1/2,1/2])); 
                                 3  1     1  1
(%o1)                         1·|-, -> ⨂ |-, ->
                                 2  2     2  2
(%i2) b:tpdagger(k); 
                                 3  1     1  1
(%o2)                         1·<-, -| ⨂ <-, -|
                                 2  2     2  2
(%i3) J1p2m(k); 
                                   2  3  3     1    1
(%o3)                  sqrt(3) hbar ·|-, -> ⨂ |-, - ->
                                      2  2     2    2
(%i4) J1m2p(k); 
(%o4)                                  0
@end group
@end example

@anchor{J1m2p}
@deffn {Function} J1m2p (@emph{tpket})
@code{J1m2p} returns @code{(J@sub{1-}J@sub{2+})} for the tpket.
@end deffn

@anchor{J1zJ2z}
@deffn {Function} J1zJ2z (@emph{tpket})
@code{J1zJ2z} returns @code{(J@sub{1z}J@sub{2z})} for the tpket.
@end deffn

@anchor{Jtsqr}
@deffn {Function} Jtsqr (@emph{tpket})
@code{Jtsqr} returns @code{(J@sub{1}@sup{2}+J@sub{2}@sup{2}+
J@sub{1+}J@sub{2-}+J@sub{1-}J@sub{2+}+J@sub{1z}J@sub{2z})} for the
tpket.
@end deffn

@example
@group
(%i1) k:tpket(ket([3/2,-1/2]),ket([1/2,1/2])); 
                                3    1     1  1
(%o1)                        1·|-, - -> ⨂ |-, ->
                                2    2     2  2
(%i2) B:tpdagger(k); 
                                3    1     1  1
(%o2)                        1·<-, - -| ⨂ <-, -|
                                2    2     2  2
(%i3) K2:Jtsqr(k); 
                 2  3    1     1  1          2  3  1     1    1
(%o3)      4 hbar ·|-, - -> ⨂ |-, -> + 2 hbar ·|-, -> ⨂ |-, - ->
                    2    2     2  2             2  2     2    2
(%i4) tpbraket(B,K2); 
                                          2
(%o4)                               4 hbar
@end group
@end example

@anchor{get_j}
@deffn {Function} get_j (@code{q})
@code{get_j} is a convenience function that computes @code{j} from
@code{j(j+1)=q} where @code{q} is a rational number. This function is
useful after using the function @code{Jtsqr}.
@end deffn

@example
@group
(%i1) get_j(15/4); 
                                         3
(%o1)                                j = -
                                         2
@end group
@end example

@page
@subsection Example computations

For the first example, let us see how to determine the total spin state
@code{|j,m>} of the two-particle state @code{|1/2,1/2;1,1>}.

@example
@group
(%i1) k:tpket(jmtop(1/2),jmtop(1)); 
                                 1  1
(%o1)                         1·|-, -> ⨂ |1, 1>
                                 2  2
(%i2) Jtsqr(k); 
                                 2
                          15 hbar   1  1
(%o2)                     --------·|-, -> ⨂ |1, 1>
                             4      2  2
(%i3) get_j(15/4); 
                                         3
(%o3)                                j = -
                                         2
@end group
@end example

This is an eigenket of @code{Jtsqr}, thus @code{|3/2,3/2> =
|1/2,1/2;1,1>}, and it is also the top state. One can now apply the
lowering operator to find the other states: @code{|3/2,1/2>},
@code{|3/2,-1/2>}, and @code{|3/2,-3/2>}.

@example
@group
(%i1) k:tpket(jmtop(1/2),jmtop(1)); 
                                 1  1
(%o1)                         1·|-, -> ⨂ |1, 1>
                                 2  2
(%i2) k2:Jtm(k); 
                         1  1                   1    1
(%o2)      sqrt(2) hbar·|-, -> ⨂ |1, 0> + hbar·|-, - -> ⨂ |1, 1>
                         2  2                   2    2
(%i3) k3:Jtm(k2); 
          3/2     2  1    1                   2  1  1
(%o3)    2    hbar ·|-, - -> ⨂ |1, 0> + 2 hbar ·|-, -> ⨂ |1, - 1>
                     2    2                      2  2
(%i4) k4:Jtm(k3); 
               3  1    1                     3  1    1
(%o4)    4 hbar ·|-, - -> ⨂ |1, - 1> + 2 hbar ·|-, - -> ⨂ |1, - 1>
                  2    2                        2    2
@end group
@end example


@page
In the example below we calculate the Clebsch-Gordan coefficients of the
two-particle state with two spin-1/2 particles. We begin by defining the
top rung of the ladder and stepping down. To calculate the coefficients
one first creates the tensor product top state, and computes the values
for the total angular momentum @code{|J,M>} at the top of the ladder
@code{M=J}. For the first step down the ladder one computes @code{Jm
|J,J>}, which must be equal to @code{Jtm |j1,j1;j2,j2>}. We then divide
by the coefficient of @code{|J,J-1>}. This gives first set of
coefficients, which in general are given by
@code{<J,M||j1,m1;j2,m2>}. One then continues down the ladder to
compute the others.

@example
@group
(%i1) top:tpket(jmtop(1/2),jmtop(1/2)); 
                                 1  1     1  1
(%o1)                         1·|-, -> ⨂ |-, ->
                                 2  2     2  2
(%i2) Jtsqr(top); 
                                 2  1  1     1  1
(%o2)                      2 hbar ·|-, -> ⨂ |-, ->
                                    2  2     2  2
(%i3) get_j(2); 
(%o3)                                j = 1
(%i4) Jtz(top); 
                                  1  1     1  1
(%o4)                       hbar·|-, -> ⨂ |-, ->
                                  2  2     2  2
(%i5) JMtop:ket([1,1]); 
(%o5)                               |1, 1>
(%i6) mid:Jtm(top); 
                    1  1     1    1          1    1     1  1
(%o6)         hbar·|-, -> ⨂ |-, - -> + hbar·|-, - -> ⨂ |-, ->
                    2  2     2    2          2    2     2  2
(%i7) Jm(JMtop); 
(%o7)                         sqrt(2) |1, 0> hbar
(%i8) mid:tpscmult(1/(sqrt(2)*hbar),mid); 
              1     1  1     1    1       1     1    1     1  1
(%o8)      -------·|-, -> ⨂ |-, - -> + -------·|-, - -> ⨂ |-, ->
           sqrt(2)  2  2     2    2    sqrt(2)  2    2     2  2
(%i9) bot:Jtm(mid); 
                                    1    1     1    1
(%o9)                 sqrt(2) hbar·|-, - -> ⨂ |-, - ->
                                    2    2     2    2
(%i10) Jm(ket([1,0])); 
(%o10)                       sqrt(2) |1, - 1> hbar
(%i11) bot:tpscmult(1/(sqrt(2)*hbar),bot); 
                               1    1     1    1
(%o11)                      1·|-, - -> ⨂ |-, - ->
                               2    2     2    2
@end group
@end example

@page
@section General tensor products

Tensor products are represented as lists in the @code{qm} package. The
ket tensor product @code{|z+,z+>} can be represented as
@code{ket([u,d])}, for example, and the bra tensor product @code{<a,b|}
is represented as @code{bra([a,b])} for states @code{a} and
@code{b}. For a tensor product where the identity is one of the elements
of the product, substitute the string @code{Id} in the ket or bra at the
desired location. See the examples below for the use of the identity in
tensor products.

Examples below show how to create abstract tensor products that contain
the identity element @code{Id} and how to take the bracket of these
tensor products.

@example
@group
(%i1) K:ket([a1,b1]); 
(%o1)                              |a1, b1>
(%i2) B:bra([a2,b2]); 
(%o2)                              <a2, b2|
(%i3) braket(B,K); 
(%o3)                kron_delta(a1, a2) kron_delta(b1, b2)
@end group
@group
(%i1) bra([a1,Id,c1]) . ket([a2,b2,c2]); 
(%o1)          |-, b2, -> kron_delta(a1, a2) kron_delta(c1, c2)
(%i2) bra([a1,b1,c1]) . ket([Id,b2,c2]); 
(%o2)          <a1, -, -| kron_delta(b1, b2) kron_delta(c1, c2)
@end group
@end example

In the next example we construct the state function for an entangled
Bell pair, construct the density matrix, and then trace over the first
particle to obtain the density submatrix for particle 2.

@example
@group
(%i1) bell:(1/sqrt(2))*(ket([u,d])-ket([d,u])); 
                                |u, d> - |d, u>
(%o1)                           ---------------
                                    sqrt(2)
(%i2) rho:bell . dagger(bell); 
      |u, d> . <u, d| - |u, d> . <d, u| - |d, u> . <u, d| + |d, u> . <d, u|
(%o2) ---------------------------------------------------------------------
                                        2
(%i3) assume(not equal(u,d)); 
(%o3)                          [notequal(u, d)]
(%i4) trace1:bra([u,Id]) . rho . ket([u,Id])+bra([d,Id]) . rho . ket([d,Id]); 
                       |-, u> . <-, u|   |-, d> . <-, d|
(%o4)                  --------------- + ---------------
                              2                 2
@end group
@end example

One can also construct the density matrix using the function @code{matrep}.

@anchor{matrep}
@deffn {Function} matrep (@code{A,B})
Given an abstract representation of an operator, e.g.  @code{A = |a>
. <b| + |b> . <a|}, the function @code{matrep} takes the operator
@code{A} and basis set @code{B} and constructs the matrix representation
of @code{A}. NOTE: if there are symbolic constants as coefficients in
the abstract representation they must be @code{declared}d as scalar for
the simplification rules to work properly with the non-commutative ``.''
operator.
@end deffn

@example
@group
(%i1) bell:(1/sqrt(2))*(ket([1,0])-ket([0,1])); 
                                |1, 0> - |0, 1>
(%o1)                           ---------------
                                    sqrt(2)
(%i2) rho:bell . dagger(bell); 
      |1, 0> . <1, 0| - |1, 0> . <0, 1| - |0, 1> . <1, 0| + |0, 1> . <0, 1|
(%o2) ---------------------------------------------------------------------
                                        2
(%i3) B:[ket([1,1]),ket([1,0]),ket([0,1]),ket([0,0])]; 
(%o3)                  [|1, 1>, |1, 0>, |0, 1>, |0, 0>]
(%i4) matrep(rho,B); 
                              [ 0   0    0   0 ]
                              [                ]
                              [     1     1    ]
                              [ 0   -   - -  0 ]
                              [     2     2    ]
(%o4)                         [                ]
                              [      1   1     ]
                              [ 0  - -   -   0 ]
                              [      2   2     ]
                              [                ]
                              [ 0   0    0   0 ]
(%i5) declare([a,b],scalar); 
(%o5)                                done
(%i6) O:a*ket([1]) . bra([0])+b*ket([0]) . bra([1]); 
(%o6)                    (|0> . <1|) b + (|1> . <0|) a
(%i7) B:[ket([1]),ket([0])]; 
(%o7)                             [|1>, |0>]
(%i8) matrep(O,B); 
                                   [ 0  a ]
(%o8)                              [      ]
                                   [ b  0 ]
@end group
@end example

@subsection Abstract basis set generator

@anchor{basis_set}
@deffn {Function} basis_set (@code{n,[l@sub{1},l@sub{2},@dots{}]})
The function @code{basis_set} takes two arguments, @code{n} is the
number of particles, and the second argument is a list of labels of the
particle states. The number of elements in the basis set is
@code{m@sup{n}}, where @code{m} is the number of states per particle.
@end deffn

@example
@group
(%i1) basis_set(2,[0,1]); 
(%o1)                  [|1, 1>, |1, 0>, |0, 1>, |0, 0>]
(%i2) basis_set(3,[u,d]); 
(%o2) [|d, d, d>, |d, d, u>, |d, u, d>, |d, u, u>, |u, d, d>, |u, d, u>, 
                                                          |u, u, d>, |u, u, u>]
@end group
@end example

@anchor{complete}
@deffn {Function} complete (@code{B})
The function @code{complete} generates the completeness relation
for the basis set @code{B}.
@end deffn

@example
@group
(%i1) B:basis_set(1,[0,1]); 
(%o1)                             [|1>, |0>]
(%i2) complete(B); 
(%o2)                        |1> . <1| + |0> . <0|
@end group
@end example

@page
@subsection Example calculation of matrix elements

Let us see how to compute the matrix elements of the operator
@code{(J1z-J1z)} in the z-basis for two spin-1/2 particles.  First, we
define the four basis kets of the form
@code{|j@sub{1},m@sub{1};j@sub{2},m@sub{2}>}. Next we define the
Hamiltonian and then use the function @code{matrep}.

@example
@group
(%i1) b1:tpket(ket([1/2,1/2]),ket([1/2,1/2])); 
                                 1  1     1  1
(%o1)                         1·|-, -> ⨂ |-, ->
                                 2  2     2  2
(%i2) b2:tpket(ket([1/2,1/2]),ket([1/2,-1/2])); 
                                1  1     1    1
(%o2)                        1·|-, -> ⨂ |-, - ->
                                2  2     2    2
(%i3) b3:tpket(ket([1/2,-1/2]),ket([1/2,1/2])); 
                                1    1     1  1
(%o3)                        1·|-, - -> ⨂ |-, ->
                                2    2     2  2
(%i4) b4:tpket(ket([1/2,-1/2]),ket([1/2,-1/2])); 
                               1    1     1    1
(%o4)                       1·|-, - -> ⨂ |-, - ->
                               2    2     2    2
(%i5) B:[b1,b2,b3,b4]; 
          1  1     1  1      1  1     1    1      1    1     1  1
(%o5) [1·|-, -> ⨂ |-, ->, 1·|-, -> ⨂ |-, - ->, 1·|-, - -> ⨂ |-, ->, 
          2  2     2  2      2  2     2    2      2    2     2  2
                                                          1    1     1    1
                                                       1·|-, - -> ⨂ |-, - ->]
                                                          2    2     2    2
(%i6) H1:omega*(J1z-J2z); 
(%o6)                          (J1z - J2z) omega
(%i7) declare(omega,scalar); 
(%o7)                                done
(%i8) matrep(H1,B); 
                      [ 0      0            0        0 ]
                      [                                ]
                      [ 0  hbar omega       0        0 ]
(%o8)                 [                                ]
                      [ 0      0       - hbar omega  0 ]
                      [                                ]
                      [ 0      0            0        0 ]
@end group
@end example

@subsection Stationary states from a Hamiltonian

@anchor{stationary}
@deffn {Function} stationary (@code{evals,evecs,basis})
The function @code{stationary} takes the output of the
@code{eigenvectors} command and a basis set and constructs
the stationary states from the basis used to construct
the matrix representation of the Hamiltonian.
@end deffn

@noindent
Example:

The hyperfine splitting in the hydrogen atom is due to the
spin-spin interaction of the electron and the proton. The
Hamiltonian is  2*A/hbar^2 * (S@sub{1} @bullet{} S@sub{2}). Let's calculate
the energy levels and the stationary states.

@example
@group
(%i1) declare(A,scalar); 
(%o1)                                done
(%i2) Hhyp:(A/hbar^2)*(J1p2m+J1m2p+2*J1zJ2z); 
                         A (2 J1zJ2z + J1p2m + J1m2p)
(%o2)                    ----------------------------
                                        2
                                    hbar
(%i3) Hmat:matrep(Hhyp,bj1212); 
                              [ A              ]
                              [ -   0    0   0 ]
                              [ 2              ]
                              [                ]
                              [      A         ]
                              [ 0  - -   A   0 ]
                              [      2         ]
(%o3)                         [                ]
                              [           A    ]
                              [ 0   A   - -  0 ]
                              [           2    ]
                              [                ]
                              [              A ]
                              [ 0   0    0   - ]
                              [              2 ]
(%i4) [evals,evecs]:eigenvectors(Hmat); 
           3 A  A
(%o4) [[[- ---, -], [1, 3]], [[[0, 1, - 1, 0]], 
            2   2
                                   [[1, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1]]]]
(%i5) states:stationary(evals,evecs,bj1212); 
          1  1     1    1           1    1     1  1      1  1     1  1
(%o5) [1·|-, -> ⨂ |-, - -> + (- 1)·|-, - -> ⨂ |-, ->, 1·|-, -> ⨂ |-, ->, 
          2  2     2    2           2    2     2  2      2  2     2  2
           1  1     1    1       1    1     1  1      1    1     1    1
        1·|-, -> ⨂ |-, - -> + 1·|-, - -> ⨂ |-, ->, 1·|-, - -> ⨂ |-, - ->]
           2  2     2    2       2    2     2  2      2    2     2    2
(%i6) Jtz(states[1]); 
(%o6)                                  0
@end group
@end example

@subsection Matrix trace functions

@anchor{qm_mtrace}
@deffn {Function} qm_mtrace (@emph{matrix})
The function @code{qm_mtrace} is the usual matrix trace; it takes
a square matrix and returns the sum of the diagonal components.
@end deffn

@anchor{qm_atrace}
@deffn {Function} qm_atrace (@code{A,B})
The function @code{qm_atrace} takes an abstract operator @code{A} and a
basis @code{B} and attempts to compute the matrix representation using
the @code{matrep} function.  If successful it will return the matrix
trace of the resulting matrix.
@end deffn

@example
@group
(%i1) B:[ket([1]),ket([0])]; 
(%o1)                             [|1>, |0>]
(%i2) declare(c,scalar); 
(%o2)                                done
(%i3) A:c*ket([1]) . bra([1]); 
(%o3)                            (|1> . <1|) c
(%i4) matrep(A,B); 
                                   [ c  0 ]
(%o4)                              [      ]
                                   [ 0  0 ]
(%i5) qm_atrace(A,B); 
(%o5)                                  c
(%i6) bell:(1/sqrt(2))*(ket([1,0])-ket([0,1])); 
                                |1, 0> - |0, 1>
(%o6)                           ---------------
                                    sqrt(2)
(%i7) rho:bell . dagger(bell); 
      |1, 0> . <1, 0| - |1, 0> . <0, 1| - |0, 1> . <1, 0| + |0, 1> . <0, 1|
(%o7) ---------------------------------------------------------------------
                                        2
(%i8) trace1:bra([1,Id]) . rho . ket([1,Id])+bra([0,Id]) . rho . ket([0,Id]); 
                       |-, 1> . <-, 1|   |-, 0> . <-, 0|
(%o8)                  --------------- + ---------------
                              2                 2
(%i9) B:[ket([Id,1]),ket([Id,0])]; 
(%o9)                         [|Id, 1>, |Id, 0>]
(%i10) matrep(trace1,B); 
                                   [ 1    ]
                                   [ -  0 ]
                                   [ 2    ]
(%o10)                             [      ]
                                   [    1 ]
                                   [ 0  - ]
                                   [    2 ]
@end group
@end example


@section Quantum harmonic oscillator

The @code{qm} package can perform simple quantum harmonic oscillator
calculations involving the ladder operators @code{a@sup{+}} and
@code{a@sup{-}}. These are referred to in the package as @code{ap} and
@code{am} respectively. For computations with arbitrary states to work
you must @code{declare} the harmonic oscillator state, say @code{n}, to
be both @code{scalar} and @code{integer}, as shown in the examples
below.

@anchor{ap}
@deffn {Function} ap
@code{ap} is the raising operator @code{a@sup{+}} for quantum harmonic
oscillator states.
@end deffn

@anchor{am}
@deffn {Function} am
@code{a} is the lowering operator @code{a@sup{-}} for quantum harmonic
oscillator states.
@end deffn

A common problem is to compute the 1st order change in energy of a state
due to a perturbation of the harmonic potential, say an additional
factor @code{V(x) = x^2 + g*x^4} for small @code{g}. This example is
performed below, ignoring any physical constants in the problem.

@example
@group
(%i1) declare(n,integer,n,scalar); 
(%o1)                                done
(%i2) ap . ket([n]); 
(%o2)                         sqrt(n + 1) |n + 1>
(%i3) am . ket([n]); 
(%o3)                           |n - 1> sqrt(n)
(%i4) bra([n]) . (ap+am)^^4 . ket([n]); 
                                   2
(%o4)                           6 n  + 6 n + 3
@end group
@end example

@*
Another package that handles quantum mechanical operators is
@code{operator_algebra} written by Barton Willis.

@section General analytic calculations

To perform more abstract calculations we define two new operator types:
@code{qop} and @code{eigenop}. A @code{qop} is a quantum operator whose
actions on kets are undefined, outside of yielding an abstract matrix
element. An @code{eigenop} is a quantum operator whose action on kets
@code{|i>} yields @code{E@sub{i} |i>}. These operators must be declared
using the following two functions.

@anchor{declare_qop}
@deffn {Function} declare_qop (@emph{symbol})
The function @code{declare_qop} declares a symbol to be a quantum
operator.  The action of a @code{qop} on kets is undefined, however
@code{qop}s are allowed to enter summations and matrix elements are
displayed if kets are represented in a numeral basis, i.e., @code{<i|
. H . |j> = H@sub{ij}}.
@end deffn

@example
@group
(%i1) declare_qop(H); 
(%o1)                                 qop
(%i2) bra([i]) . H . ket([j]); 
(%o2)                                H
                                      i, j
@end group
@end example

@anchor{declare_eigenop}
@deffn {Function} declare_eigenop (@emph{symbol})
The function @code{declare_eigenop} declares a symbol to be a quantum
operator (qop) and also an @code{eigenop}. The action of a
@code{eigenop} on kets is defined by the ket symbol, e.g.  @code{H . |i>
= E@sub{i} |i>}.
@end deffn

@example
@group
(%i1) declare_eigenop(H); 
(%o1)                               eigenop
(%i2) H . ket([j]); 
(%o2)                               E  |j>
                                     j
(%i3) bra([i]) . H . ket([j]); 
(%o3)                         kron_delta(i, j) E
                                                j
@end group
@end example

@anchor{Uop}
@deffn {Function} Uop (@code{H,t})
@code{Uop(H,t)} is the time evolution operator for eigenop Hamiltonian @code{H}. It
is defined as the matrix exponential @code{matrixexp(-%i*H*t/hbar)}.
@end deffn


@section Example: Two-state systems

In this section we recast the Schrodinger equation in terms
of coefficient functions generally, and then use the resulting
equations to examine a simple two-state system.

@example
@group
(%i1) declare_qop(H); 
(%o1)                                 qop
(%i2) declare(c,complex); 
(%o2)                                done
(%i3) depends(c,t); 
(%o3)                               [c(t)]
(%i4) psi:sum(c[i]*ket([i]),i,1,N); 
                                  N
                                 ____
                                 \
(%o4)                             >    c  |i>
                                 /      i
                                 ----
                                 i = 1
(%i5) schro:%i*diff(psi,t) = H . psi; 
                      N                     N
                     ____                  ____
                     \      d              \
(%o5)             %i  >    (-- (c )) |i> =  >    H . (c  |i>)
                     /      dt   i         /           i
                     ----                  ----
                     i = 1                 i = 1
(%i6) bra([j]) . schro; 
                                         N
                                        ____
                             d          \
(%o6)                    %i (-- (c )) =  >    c  H
                             dt   j     /      i  j, i
                                        ----
                                        i = 1
@end group
@end example

This is the general formula (with hbar=1) found in textbooks. Now let us
specialize to a two-state system and solve it. We will specify the
matrix elements for a two-state system with transitions between two
states of the same energy.

@example
@group
(%i1) declare_qop(H); 
(%o1)                                 qop
(%i2) psi2:c[1](t)*ket([1])+c[2](t)*ket([2]); 
(%o2)                        |2> c (t) + |1> c (t)
                                  2           1
(%i3) schro2:%i*diff(psi2,t) = H . psi2; 
               d                  d
(%o3) %i (|2> (-- (c (t))) + |1> (-- (c (t)))) = 
               dt   2             dt   1
                                              H . (|2> c (t)) + H . (|1> c (t))
                                                        2                 1
(%i4) eq1:bra([1]) . schro2; 
                      d
(%o4)             %i (-- (c (t))) = H     c (t) + H     c (t)
                      dt   1         1, 2  2       1, 1  1
(%i5) eq2:bra([2]) . schro2; 
                      d
(%o5)             %i (-- (c (t))) = H     c (t) + H     c (t)
                      dt   2         2, 2  2       2, 1  1
(%i6) H:matrix([E0,-A],[-A,E0]); 
                                 [ E0   - A ]
(%o6)                            [          ]
                                 [ - A  E0  ]
(%i7) assume(A > 0,E0 > 0); 
(%o7)                           [A > 0, E0 > 0]
(%i8) eq1:''eq1; 
                         d
(%o8)                %i (-- (c (t))) = E0 c (t) - A c (t)
                         dt   1            1         2
(%i9) eq2:''eq2; 
                         d
(%o9)                %i (-- (c (t))) = E0 c (t) - A c (t)
                         dt   2            2         1
(%i10) soln:desolve([eq1,eq2],[c[1](t),c[2](t)])$ 
(%i11) add:fullsimp(soln[1]+soln[2]); 
                                %i A t - %i E0 t
(%o11)        c (t) + c (t) = %e                 (c (0) + c (0))
               2       1                           2       1
(%i12) sub:fullsimp(soln[1]-soln[2]); 
                                - %i E0 t - %i A t
(%o12)      c (t) - c (t) = - %e                   (c (0) - c (0))
             1       2                               2       1
@end group
@end example



@section Pre-defined quantities

There are some pre-defined quantities in the file @code{predef.mac}
that may be convenient for the user. These include Bell states, and 
some basis sets that are tedious to input.

@verbatim
bell1: 1/sqrt(2)*(ket([1,0])-ket([0,1]));
bell2: 1/sqrt(2)*(ket([1,0])+ket([0,1]));
bell3: 1/sqrt(2)*(ket([0,0])+ket([1,1]));
bell4: 1/sqrt(2)*(ket([0,0])-ket([1,1]));

ghz1: 1/sqrt(2)*(ket([0,0,0])-ket([1,1,1]));
ghz2: 1/sqrt(2)*(ket([0,0,0])+ket([1,1,1]));


/* pre-defined tpket bases */
bj1212: [ [tpket,1,ket([1/2,1/2]),ket([1/2,1/2])],
        [tpket,1,ket([1/2,1/2]),ket([1/2,-1/2])],
        [tpket,1,ket([1/2,-1/2]),ket([1/2,1/2])],
        [tpket,1,ket([1/2,-1/2]),ket([1/2,-1/2])] ];

bj112: [ [tpket,1,ket([1,1]),ket([1/2,1/2])],
         [tpket,1,ket([1,1]),ket([1/2,-1/2])],
         [tpket,1,ket([1,0]),ket([1/2,1/2])],
         [tpket,1,ket([1,0]),ket([1/2,-1/2])],         
         [tpket,1,ket([1,-1]),ket([1/2,1/2])],
         [tpket,1,ket([1,-1]),ket([1/2,-1/2])] ];

bj11:  [ [tpket,1,ket([1,1]),ket([1,1])],
         [tpket,1,ket([1,1]),ket([1,0])],
         [tpket,1,ket([1,1]),ket([1,-1])],
         [tpket,1,ket([1,0]),ket([1,1])],
         [tpket,1,ket([1,0]),ket([1,0])],
         [tpket,1,ket([1,0]),ket([1,-1])],         
         [tpket,1,ket([1,-1]),ket([1,1])],
         [tpket,1,ket([1,-1]),ket([1,0])],
         [tpket,1,ket([1,-1]),ket([1,-1])] ];
@end verbatim

@node Function and Variable Index, , Top, Top
@appendix Function and Variable index
@printindex fn
@printindex vr

@bye
