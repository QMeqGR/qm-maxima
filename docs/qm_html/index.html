<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Top (Package qm)</title>

<meta name="description" content="Top (Package qm)">
<meta name="keywords" content="Top (Package qm)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#Top" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="../dir_html/index.html" rel="up" title="(dir)">
<link href="#Introduction-to-package-qm" rel="next" title="Introduction to package qm">
<link href="../dir_html/index.html" rel="prev" title="(dir)">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">



<div class="top-level-extent" id="Top">
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<a class="top" id="SEC_Top"></a>


<ul class="mini-toc">
<li><a href="#Package-qm" accesskey="1">Package qm</a></li>
<li><a href="Function-and-Variable-Index.html" accesskey="2">Function and Variable index</a></li>
</ul>
<div class="chapter-level-extent" id="Package-qm">
<h2 class="chapter"><span>1 Package qm<a class="copiable-link" href="#Package-qm"> &para;</a></span></h2>

<ul class="mini-toc">
<li><a href="#Introduction-to-package-qm" accesskey="1">Introduction to package qm</a></li>
<li><a href="#Functions-and-Variables-for-qm" accesskey="2">Functions and Variables for qm</a></li>
<li><a href="#Rotation-operators" accesskey="3">Rotation operators</a></li>
<li><a href="#Time_002devolution-operator" accesskey="4">Time-evolution operator</a></li>
<li><a href="#Tensor-products" accesskey="5">Tensor products</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-package-qm">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-qm" accesskey="n" rel="next">Functions and Variables for qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-package-qm-1"><span>1.1 Introduction to package qm<a class="copiable-link" href="#Introduction-to-package-qm-1"> &para;</a></span></h3>

<p>The <code class="code">qm</code> package was written by Eric Majzoub, University of
Missouri (email: majzoube-at-umsystem.edu), with help from Robert Dodier
and Barton Willis.
</p>
<p>This purpose of this package is to provide computational tools for
solving quantum mechanics problems in a finite-dimensional Hilbert
space. It was written with students in mind and is appropriate for
upper-level undergraduate quantum mechanics at the level of Townsend&rsquo;s
<em class="emph">A Modern Introduction to Quantum Mechanics</em>. Please report any
errors or unexpected behavior by submitting an issue on the Github page
for this project.
</p>
<p>The package is loaded with: <code class="code">load(qm);</code>
</p>
<p>The <code class="code">qm</code> package provides functions and standard definitions to
solve quantum mechanics problems in a finite dimensional Hilbert
space. For example, one can calculate the outcome of Stern-Gerlach
experiments using built-in definitions of the Sx, Sy, and Sz operators
for arbitrary spin, e.g. <code class="code">s={1/2, 1, 3/2, &hellip;}</code>. For spin-1/2
the standard basis kets in the <code class="code">x</code>, <code class="code">y</code>, and <code class="code">z</code>-basis
are available as <code class="code">{xp,xm}</code>, <code class="code">{yp,ym}</code>, and
<code class="code">{zp,zm}</code>, respectively. One can create general ket vectors with
arbitrary but finite dimension and perform standard computations such as
expectation value, variance, etc. The angular momentum <var class="var">|j,m&gt;</var>
representation of kets is also available. Tensor product states for
multiparticle systems can be created to perform calculations on those
systems.
</p>
<p>Let us consider a simple example involving spin-1/2 particles.
A bra vector in the <code class="code">z</code>-basis may be written as 
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">&lt;psi| = a &lt;z+| + b &lt;z-|</code>.
</p>
<p>The bra <code class="code">&lt;psi|</code> will be represented in Maxima by the row vector
<code class="code">[a b]</code>, where the basis vectors are
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">&lt;z+| = [1 0]</code>
</p>
<p>and
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">&lt;z-| = [0 1]</code>.
</p>
<p>In a Maxima session this looks like the following. The basis kets
<code class="code">{zp,zm}</code> are transformed into bras using the <code class="code">dagger</code>
function.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) psi_bra:a*dagger(zp)+b*dagger(zm);
(%o1)                              [ a  b ]
</pre></div></div>


<ul class="mini-toc">
<li><a href="#Types-of-kets-and-bras" accesskey="1">Types of kets and bras</a></li>
<li><a href="#Special-ket-types" accesskey="2">Special ket types</a></li>
</ul>
<div class="subsection-level-extent" id="Types-of-kets-and-bras">
<h4 class="subsection"><span>1.1.1 Types of kets and bras<a class="copiable-link" href="#Types-of-kets-and-bras"> &para;</a></span></h4>

<p>There are two types of kets and bras available in the <code class="code">qm</code> package,
the first type is given by a <em class="emph">matrix representation</em>, as returned
by the functions <code class="code">mbra</code> and <code class="code">mket</code>. <code class="code">mket</code>s are column
vectors and <code class="code">mbra</code>s are row vectors, and their components are
entered as Maxima <em class="emph">lists</em> in the <code class="code">mbra</code> and <code class="code">mket</code>
functions. The second type of bra or ket is <em class="emph">abstract</em>; there is no
matrix representation. Abstract bras and kets are entered using the
<code class="code">bra</code> and <code class="code">ket</code> functions, while also using Maxima lists for
the elements. These general kets are displayed in Dirac
notation. Abstract bras and kets are used for both the <code class="code">(j,m)</code>
representation of states and also for tensor products. For example, a
tensor product of two ket vectors <code class="code">|a&gt;</code> and <code class="code">|b&gt;</code> is input as
<code class="code">ket([a,b])</code> and displayed as
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">|a,b&gt;</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(general ket)
</p>
<p>Note that abstract kets and bras are <em class="emph">assumed to be
orthonormal</em>. These general bras and kets may be used to build
arbitrarily large tensor product states.
</p>
<p>The following examples illustrate some of the basic capabilities of the
<code class="code">qm</code> package. Here both abstract, and concrete (matrix
representation) kets are shown. The last example shows how to contstruct
an entangled Bell pair.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ket([a,b])+ket([c,d]);
(%o1)                           |c, d&gt; + |a, b&gt;
(%i2) mket([a,b]);
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) mbra([a,b]);
(%o3)                              [ a  b ]
(%i4) bell:(1/sqrt(2))*(ket([u,d])-ket([d,u]));
                                |u, d&gt; - |d, u&gt;
(%o4)                           ---------------
                                    sqrt(2)
(%i5) dagger(bell);
                                &lt;u, d| - &lt;d, u|
(%o5)                           ---------------
                                    sqrt(2)
</pre></div></div>

<p>Note that <code class="code">ket([a,b])</code> is treated as tensor product of states
<code class="code">a</code> and <code class="code">b</code> as shown below.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) braket(bra([a1,b1]),ket([a2,b2]));
(%o1)                kron_delta(a1, a2) kron_delta(b1, b2)
</pre></div></div>

<p>Constants that multiply kets and bras must be declared complex by
the user in order for the dagger function to properly conjugate
such constants. The example below illustrates this behavior.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:a*ket([1])+b*ket([2]);
(%o2)                            |2&gt; b + |1&gt; a
(%i3) psidag:dagger(psi);
(%o3)                 &lt;2| conjugate(b) + &lt;1| conjugate(a)
(%i4) psidag . psi;
(%o4)                   b conjugate(b) + a conjugate(a)
</pre></div></div>

<p>The following shows how to declare a ket with both real and
complex components in the matrix representation.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([c1,c2],complex,r,real);
(%o1)                                done
(%i2) k:mket([c1,c2,r]);
                                    [ c1 ]
                                    [    ]
(%o2)                               [ c2 ]
                                    [    ]
                                    [ r  ]
(%i3) b:dagger(k);
(%o3)                 [ conjugate(c1)  conjugate(c2)  r ]
(%i4) b . k;
                    2
(%o4)              r  + c2 conjugate(c2) + c1 conjugate(c1)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Special-ket-types">
<h4 class="subsection"><span>1.1.2 Special ket types<a class="copiable-link" href="#Special-ket-types"> &para;</a></span></h4>

<p>Some kets are difficult to work with using either the matrix
representation or the general ket representation. These include tensor
products of (j,m) kets used in the addition of angular momentum
computations. For this reason there are a set of <code class="code">tpket</code>s and
associated <code class="code">tpXX</code> functions defined in section <code class="code">(j,m)-kets and
bras</code>.
</p>
<hr>
</div>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-qm">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-package-qm" accesskey="p" rel="prev">Introduction to package qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-qm-1"><span>1.2 Functions and Variables for qm<a class="copiable-link" href="#Functions-and-Variables-for-qm-1"> &para;</a></span></h3>

<dl class="first-defvr">
<dt class="defvr" id="index-hbar"><span class="category-def">Variable: </span><span><strong class="def-name">hbar</strong><a class="copiable-link" href="#index-hbar"> &para;</a></span></dt>
<dd><p>Planck&rsquo;s constant divided by <code class="code">2*%pi</code>. <code class="code">hbar</code> is not given a
floating point value, but is declared to be a real number greater than
zero.
</p></dd></dl>

<a class="anchor" id="ket"></a><dl class="first-deffn">
<dt class="deffn" id="index-ket"><span class="category-def">Function: </span><span><strong class="def-name">ket</strong> <var class="def-var-arguments">([<code class="code">k<sub class="sub">1</sub></code>,<code class="code">k<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-ket"> &para;</a></span></dt>
<dd><p><code class="code">ket</code> creates a general state ket, or tensor product, with symbols
<code class="code">k<sub class="sub">i</sub></code> representing the states. The state kets <code class="code">k<sub class="sub">i</sub></code>
are assumed to be orthonormal.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([u,d]);
(%o1)                               |u, d&gt;
(%i2) b:bra([u,d]);
(%o2)                               &lt;u, d|
(%i3) b . k;
(%o3)                                  1
</pre></div></div>

<a class="anchor" id="ketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-ketp"><span class="category-def">Function: </span><span><strong class="def-name">ketp</strong> <var class="def-var-arguments">(abstract ket)</var><a class="copiable-link" href="#index-ketp"> &para;</a></span></dt>
<dd><p><code class="code">ketp</code> is a predicate function for abstract kets. It returns
<code class="code">true</code> for abstract <code class="code">ket</code>s and <code class="code">false</code> for anything else.
</p></dd></dl>

<a class="anchor" id="bra"></a><dl class="first-deffn">
<dt class="deffn" id="index-bra"><span class="category-def">Function: </span><span><strong class="def-name">bra</strong> <var class="def-var-arguments">([<code class="code">b<sub class="sub">1</sub></code>,<code class="code">b<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-bra"> &para;</a></span></dt>
<dd><p><code class="code">bra</code> creates a general state bra, or tensor product, with symbols
<code class="code">b<sub class="sub">i</sub></code> representing the states. The state bras <code class="code">b<sub class="sub">i</sub></code>
are assumed to be orthonormal.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([u,d]);
(%o1)                               |u, d&gt;
(%i2) b:bra([u,d]);
(%o2)                               &lt;u, d|
(%i3) b . k;
(%o3)                                  1
</pre></div></div>

<a class="anchor" id="brap"></a><dl class="first-deffn">
<dt class="deffn" id="index-brap"><span class="category-def">Function: </span><span><strong class="def-name">brap</strong> <var class="def-var-arguments">(abstract bra)</var><a class="copiable-link" href="#index-brap"> &para;</a></span></dt>
<dd><p><code class="code">brap</code> is a predicate function for abstract bras. It returns
<code class="code">true</code> for abstract <code class="code">bra</code>s and <code class="code">false</code> for anything else.
</p></dd></dl>

<a class="anchor" id="mket"></a><dl class="first-deffn">
<dt class="deffn" id="index-mket"><span class="category-def">Function: </span><span><strong class="def-name">mket</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-mket"> &para;</a></span></dt>
<dd><p><code class="code">mket</code> creates a <em class="emph">column</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex. For a
matrix representation the elements must be entered as a list in
<code class="code">[&hellip;]</code> square brackets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([c1,c2],complex);
(%o1)                                done
(%i2) mket([c1,c2]);
                                    [ c1 ]
(%o2)                               [    ]
                                    [ c2 ]
(%i3) facts();
(%o3) [kind(hbar, real), hbar &gt; 0, kind(c1, complex), kind(c2, complex)]
</pre></div></div>

<a class="anchor" id="mketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-mketp"><span class="category-def">Function: </span><span><strong class="def-name">mketp</strong> <var class="def-var-arguments">(<em class="emph">ket</em>)</var><a class="copiable-link" href="#index-mketp"> &para;</a></span></dt>
<dd><p><code class="code">mketp</code> is a predicate function that checks if its input is an mket,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">mketp</code> only returns <code class="code">true</code> for the matrix representation of a ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([a,b]);
(%o1)                               |a, b&gt;
(%i2) mketp(k);
(%o2)                                false
(%i3) k:mket([a,b]);
                                     [ a ]
(%o3)                                [   ]
                                     [ b ]
(%i4) mketp(k);
(%o4)                                true
</pre></div></div>

<a class="anchor" id="mbra"></a><dl class="first-deffn">
<dt class="deffn" id="index-mbra"><span class="category-def">Function: </span><span><strong class="def-name">mbra</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-mbra"> &para;</a></span></dt>
<dd><p><code class="code">mbra</code> creates a <em class="emph">row</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex.
For a matrix representation the elements must be entered as a list
in <code class="code">[&hellip;]</code> square brackets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) kill(c1,c2);
(%o1)                                done
(%i2) mbra([c1,c2]);
(%o2)                             [ c1  c2 ]
(%i3) facts();
(%o3)                    [kind(hbar, real), hbar &gt; 0]
</pre></div></div>

<a class="anchor" id="mbrap"></a><dl class="first-deffn">
<dt class="deffn" id="index-mbrap"><span class="category-def">Function: </span><span><strong class="def-name">mbrap</strong> <var class="def-var-arguments">(<em class="emph">bra</em>)</var><a class="copiable-link" href="#index-mbrap"> &para;</a></span></dt>
<dd><p><code class="code">mbrap</code> is a predicate function that checks if its input is an mbra,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">mbrap</code> only returns <code class="code">true</code> for the matrix representation of a bra.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) b:mbra([a,b]);
(%o1)                              [ a  b ]
(%i2) mbrap(b);
(%o2)                                true
</pre></div></div>

<p>Two additional functions are provided to create kets and bras in the
matrix representation. These functions conveniently attempt to
automatically <code class="code">declare</code> constants as complex. For example, if a
list entry is <code class="code">a*sin(x)+b*cos(x)</code> then only <code class="code">a</code> and <code class="code">b</code>
will be <code class="code">declare</code>-d complex and not <code class="code">x</code>.
</p>
<a class="anchor" id="autoket"></a><dl class="first-deffn">
<dt class="deffn" id="index-autoket"><span class="category-def">Function: </span><span><strong class="def-name">autoket</strong> <var class="def-var-arguments">([<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>])</var><a class="copiable-link" href="#index-autoket"> &para;</a></span></dt>
<dd><p><code class="code">autoket</code> takes a list [<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>] and
returns a ket with the coefficients <code class="code">a<sub class="sub">i</sub></code> <code class="code">declare</code>-d
complex. Simple expressions such as <code class="code">a*sin(x)+b*cos(x)</code> are allowed
and will <code class="code">declare</code> only the coefficients as complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) autoket([a,b]);
                                     [ a ]
(%o1)                                [   ]
                                     [ b ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) autoket([a*sin(x),b*sin(x)]);
                                 [ a sin(x) ]
(%o1)                            [          ]
                                 [ b sin(x) ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div></div>

<a class="anchor" id="autobra"></a><dl class="first-deffn">
<dt class="deffn" id="index-autobra"><span class="category-def">Function: </span><span><strong class="def-name">autobra</strong> <var class="def-var-arguments">([<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>])</var><a class="copiable-link" href="#index-autobra"> &para;</a></span></dt>
<dd><p><code class="code">autobra</code> takes a list [<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>] and
returns a bra with the coefficients <code class="code">a<sub class="sub">i</sub></code> <code class="code">declare</code>-d
complex. Simple expressions such as <code class="code">a*sin(x)+b*cos(x)</code> are allowed
and will <code class="code">declare</code> only the coefficients as complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) autobra([a,b]);
(%o1)                              [ a  b ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) autobra([a*sin(x),b]);
(%o1)                           [ a sin(x)  b ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div></div>

<a class="anchor" id="dagger"></a><dl class="first-deffn">
<dt class="deffn" id="index-dagger"><span class="category-def">Function: </span><span><strong class="def-name">dagger</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-dagger"> &para;</a></span></dt>
<dd><p><code class="code">dagger</code> is the quantum mechanical <em class="emph">dagger</em> function and returns
the <code class="code">conjugate</code> <code class="code">transpose</code> of its input. Arbitrary constants
must be <code class="code">declare</code>-d complex for dagger to produce the conjugate.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dagger(mbra([%i,2]));
                                   [ - %i ]
(%o1)                              [      ]
                                   [  2   ]
</pre></div></div>

<a class="anchor" id="braket"></a><dl class="first-deffn">
<dt class="deffn" id="index-braket"><span class="category-def">Function: </span><span><strong class="def-name">braket</strong> <var class="def-var-arguments">(<code class="code">psi,phi</code>)</var><a class="copiable-link" href="#index-braket"> &para;</a></span></dt>
<dd><p>Given a bra <code class="code">psi</code> and ket <code class="code">phi</code>, <code class="code">braket</code> returns the
quantum mechanical bracket <code class="code">&lt;psi|phi&gt;</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) braket(mbra([a,b,c]),mket([a,b,c]));
                                  2    2    2
(%o2)                            c  + b  + a
(%i3) braket(dagger(mket([a,b,c])),mket([a,b,c]));
(%o3)          c conjugate(c) + b conjugate(b) + a conjugate(a)
(%i4) braket(bra([a1,b1,c1]),ket([a2,b2,c2]));
(%o4)      kron_delta(a1, a2) kron_delta(b1, b2) kron_delta(c1, c2)
</pre></div></div>

<a class="anchor" id="norm"></a><dl class="first-deffn">
<dt class="deffn" id="index-norm"><span class="category-def">Function: </span><span><strong class="def-name">norm</strong> <var class="def-var-arguments">(<code class="code">psi</code>)</var><a class="copiable-link" href="#index-norm"> &para;</a></span></dt>
<dd><p>Given a <code class="code">ket</code> or <code class="code">bra</code> <code class="code">psi</code>, <code class="code">norm</code> returns the
square root of the quantum mechanical bracket <code class="code">&lt;psi|psi&gt;</code>.
The vector <code class="code">psi</code> must always be a <code class="code">ket</code>, otherwise the
function will return <code class="code">false</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) norm(mket([a,b,c]));
(%o2)       sqrt(c conjugate(c) + b conjugate(b) + a conjugate(a))
</pre></div></div>

<a class="anchor" id="magsqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-magsqr"><span class="category-def">Function: </span><span><strong class="def-name">magsqr</strong> <var class="def-var-arguments">(<code class="code">c</code>)</var><a class="copiable-link" href="#index-magsqr"> &para;</a></span></dt>
<dd><p><code class="code">magsqr</code> returns <code class="code">conjugate(c)*c</code>, the magnitude
squared of a complex number.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c,d],complex);
(%o1)                                done
(%i2) A:braket(mbra([a,b]),mket([c,d]));
(%o2)                              b d + a c
(%i3) P:magsqr(A);
(%o3) (b d + a c) (conjugate(b) conjugate(d) + conjugate(a) conjugate(c))
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Spin_002d1_002f2-state-kets-and-associated-operators" accesskey="1">Spin-1/2 state kets and associated operators</a></li>
<li><a href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators" accesskey="2">Pauli matrices and Sz, Sx, Sy operators</a></li>
<li><a href="#SX_002c-SY_002c-SZ-operators-for-any-spin" accesskey="3">SX, SY, SZ operators for any spin</a></li>
<li><a href="#Expectation-value-and-variance" accesskey="4">Expectation value and variance</a></li>
<li><a href="#Angular-momentum-representation-of-kets-and-bras" accesskey="5">Angular momentum representation of kets and bras</a></li>
<li><a href="#Angular-momentum-_0028j_002cm_0029_002dkets-and-bras" accesskey="6">Angular momentum (j,m)-kets and bras</a></li>
<li><a href="#Addition-of-angular-momentum-in-the-_0028j_002cm_0029_002drepresentation" accesskey="7">Addition of angular momentum in the (j,m)-representation</a></li>
<li><a href="#Angular-momentum-and-ladder-operators" accesskey="8">Angular momentum and ladder operators</a></li>
</ul>
<div class="subsection-level-extent" id="Spin_002d1_002f2-state-kets-and-associated-operators">
<h4 class="subsection"><span>1.2.1 Spin-1/2 state kets and associated operators<a class="copiable-link" href="#Spin_002d1_002f2-state-kets-and-associated-operators"> &para;</a></span></h4>

<p>Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states. It is spanned by two vectors. In the <var class="var">z</var>-basis
these vectors are <code class="code">{zp,zm}</code>, and the basis kets in the
<var class="var">z</var>-basis are <code class="code">{xp,xm}</code> and <code class="code">{yp,ym}</code> respectively.
</p>
<a class="anchor" id="zp"></a><dl class="first-deffn">
<dt class="deffn" id="index-zp"><span class="category-def">Function: </span><span><strong class="def-name">zp</strong><a class="copiable-link" href="#index-zp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="zm"></a><dl class="first-deffn">
<dt class="deffn" id="index-zm"><span class="category-def">Function: </span><span><strong class="def-name">zm</strong><a class="copiable-link" href="#index-zm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="xp"></a><dl class="first-deffn">
<dt class="deffn" id="index-xp"><span class="category-def">Function: </span><span><strong class="def-name">xp</strong><a class="copiable-link" href="#index-xp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="xm"></a><dl class="first-deffn">
<dt class="deffn" id="index-xm"><span class="category-def">Function: </span><span><strong class="def-name">xm</strong><a class="copiable-link" href="#index-xm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="yp"></a><dl class="first-deffn">
<dt class="deffn" id="index-yp"><span class="category-def">Function: </span><span><strong class="def-name">yp</strong><a class="copiable-link" href="#index-yp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="ym"></a><dl class="first-deffn">
<dt class="deffn" id="index-ym"><span class="category-def">Function: </span><span><strong class="def-name">ym</strong><a class="copiable-link" href="#index-ym"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) zp;
                                     [ 1 ]
(%o1)                                [   ]
                                     [ 0 ]
(%i2) zm;
                                     [ 0 ]
(%o2)                                [   ]
                                     [ 1 ]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) yp;
                                  [    1    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%o1)                             [         ]
                                  [   %i    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%i2) ym;
                                 [     1     ]
                                 [  -------  ]
                                 [  sqrt(2)  ]
(%o2)                            [           ]
                                 [     %i    ]
                                 [ - ------- ]
                                 [   sqrt(2) ]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) braket(dagger(xp),zp);
                                       1
(%o1)                               -------
                                    sqrt(2)
</pre></div></div>

<p>Switching bases is done in the following example where a <var class="var">z</var>-basis
ket is constructed and the <var class="var">x</var>-basis ket is computed.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:mket([a,b]);
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) psi_x:'xp*braket(dagger(xp),psi)+'xm*braket(dagger(xm),psi);
                    b         a              a         b
(%o3)           (------- + -------) xp + (------- - -------) xm
                 sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators">
<h4 class="subsection"><span>1.2.2 Pauli matrices and Sz, Sx, Sy operators<a class="copiable-link" href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators"> &para;</a></span></h4>

<a class="anchor" id="sigmax"></a><dl class="first-deffn">
<dt class="deffn" id="index-sigmax"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmax</code></strong><a class="copiable-link" href="#index-sigmax"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">x</var> matrix.
</p></dd></dl>

<a class="anchor" id="sigmay"></a><dl class="first-deffn">
<dt class="deffn" id="index-sigmay"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmay</code></strong><a class="copiable-link" href="#index-sigmay"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">y</var> matrix.
</p></dd></dl>

<a class="anchor" id="sigmaz"></a><dl class="first-deffn">
<dt class="deffn" id="index-sigmaz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmaz</code></strong><a class="copiable-link" href="#index-sigmaz"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">z</var> matrix.
</p></dd></dl>

<a class="anchor" id="Sx"></a><dl class="first-deffn">
<dt class="deffn" id="index-Sx"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sx</code></strong><a class="copiable-link" href="#index-Sx"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sx</var> matrix.
</p></dd></dl>

<a class="anchor" id="Sy"></a><dl class="first-deffn">
<dt class="deffn" id="index-Sy"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sy</code></strong><a class="copiable-link" href="#index-Sy"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sy</var> matrix.
</p></dd></dl>

<a class="anchor" id="Sz"></a><dl class="first-deffn">
<dt class="deffn" id="index-Sz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sz</code></strong><a class="copiable-link" href="#index-Sz"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sz</var> matrix.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) sigmay;
                                 [ 0   - %i ]
(%o1)                            [          ]
                                 [ %i   0   ]
(%i2) Sy;
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o2)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
</pre></div></div>

<a class="anchor" id="commutator"></a><dl class="first-deffn">
<dt class="deffn" id="index-commutator"><span class="category-def">Function: </span><span><strong class="def-name">commutator</strong> <var class="def-var-arguments">(<code class="code">X,Y</code>)</var><a class="copiable-link" href="#index-commutator"> &para;</a></span></dt>
<dd><p>Given two operators <code class="code">X</code> and <code class="code">Y</code>, return the
commutator <code class="code">X . Y - Y . X</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) commutator(Sx,Sy);
                           [        2             ]
                           [ %i hbar              ]
                           [ --------      0      ]
                           [    2                 ]
(%o1)                      [                      ]
                           [                    2 ]
                           [             %i hbar  ]
                           [    0      - -------- ]
                           [                2     ]
</pre></div></div>

<a class="anchor" id="anticommutator"></a><dl class="first-deffn">
<dt class="deffn" id="index-anticommutator"><span class="category-def">Function: </span><span><strong class="def-name">anticommutator</strong> <var class="def-var-arguments">(<code class="code">X,Y</code>)</var><a class="copiable-link" href="#index-anticommutator"> &para;</a></span></dt>
<dd><p>Given two operators <code class="code">X</code> and <code class="code">Y</code>, return the
commutator <code class="code">X . Y + Y . X</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) (1/2)*anticommutator(sigmax,sigmax);
                                   [ 1  0 ]
(%o1)                              [      ]
                                   [ 0  1 ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="SX_002c-SY_002c-SZ-operators-for-any-spin">
<h4 class="subsection"><span>1.2.3 SX, SY, SZ operators for any spin<a class="copiable-link" href="#SX_002c-SY_002c-SZ-operators-for-any-spin"> &para;</a></span></h4>

<a class="anchor" id="SX"></a><dl class="first-deffn">
<dt class="deffn" id="index-SX"><span class="category-def">Function: </span><span><strong class="def-name">SX</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SX"> &para;</a></span></dt>
<dd><p><code class="code">SX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sx</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<a class="anchor" id="SY"></a><dl class="first-deffn">
<dt class="deffn" id="index-SY"><span class="category-def">Function: </span><span><strong class="def-name">SY</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SY"> &para;</a></span></dt>
<dd><p><code class="code">SY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sy</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<a class="anchor" id="SZ"></a><dl class="first-deffn">
<dt class="deffn" id="index-SZ"><span class="category-def">Function: </span><span><strong class="def-name">SZ</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SZ"> &para;</a></span></dt>
<dd><p><code class="code">SZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sz</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<p>Example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SY(1/2);
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o1)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
(%i2) SX(1);
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
                         [                           ]
                         [  hbar              hbar   ]
(%o2)                    [ -------     0     ------- ]
                         [ sqrt(2)           sqrt(2) ]
                         [                           ]
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Expectation-value-and-variance">
<h4 class="subsection"><span>1.2.4 Expectation value and variance<a class="copiable-link" href="#Expectation-value-and-variance"> &para;</a></span></h4>

<a class="anchor" id="expect"></a><dl class="first-deffn">
<dt class="deffn" id="index-expect"><span class="category-def">Function: </span><span><strong class="def-name">expect</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-expect"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical expectation value of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">&lt;psi|O|psi&gt;</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(expect(Sy,xp+ym),ratsimp);
(%o1)                               - hbar
</pre></div></div>

<a class="anchor" id="qm_005fvariance"></a><dl class="first-deffn">
<dt class="deffn" id="index-qm_005fvariance"><span class="category-def">Function: </span><span><strong class="def-name">qm_variance</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-qm_005fvariance"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical variance of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">sqrt(&lt;psi|O<sup class="sup">2</sup>|psi&gt; - &lt;psi|O|psi&gt;<sup class="sup">2</sup>)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(qm_variance(Sy,xp+ym),ratsimp);
                                    %i hbar
(%o1)                               -------
                                       2
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-representation-of-kets-and-bras">
<h4 class="subsection"><span>1.2.5 Angular momentum representation of kets and bras<a class="copiable-link" href="#Angular-momentum-representation-of-kets-and-bras"> &para;</a></span></h4>

<ul class="mini-toc">
<li><a href="#Matrix-representation-of-_0028j_002cm_0029_002dkets-and-bras" accesskey="1">Matrix representation of (j,m)-kets and bras</a></li>
</ul>
<div class="subsubsection-level-extent" id="Matrix-representation-of-_0028j_002cm_0029_002dkets-and-bras">
<h4 class="subsubsection"><span>1.2.5.1 Matrix representation of (j,m)-kets and bras<a class="copiable-link" href="#Matrix-representation-of-_0028j_002cm_0029_002dkets-and-bras"> &para;</a></span></h4>

<p>The matrix representation of kets and bras in the <code class="code">qm</code> package are
represented in the <code class="code">z</code>-basis. To create a matrix representation of
of a ket or bra in the (j,m)-basis one uses the <code class="code">spin_mket</code> and
<code class="code">spin_mbra</code> functions.
</p>
<a class="anchor" id="spin_005fmket"></a><dl class="first-deffn">
<dt class="deffn" id="index-spin_005fmket"><span class="category-def">Function: </span><span><strong class="def-name">spin_mket</strong> <var class="def-var-arguments">(s,m<sub class="sub">s</sub>,[1,2])</var><a class="copiable-link" href="#index-spin_005fmket"> &para;</a></span></dt>
<dd><p><code class="code">spin_mket</code> returns a ket in the <code class="code">z</code>-basis for spin <code class="code">s</code>
and z-projection <code class="code">m<sub class="sub">s</sub></code>, for axis 1=X or 2=Y.
</p></dd></dl>

<a class="anchor" id="spin_005fmbra"></a><dl class="first-deffn">
<dt class="deffn" id="index-spin_005fmbra"><span class="category-def">Function: </span><span><strong class="def-name">spin_mbra</strong> <var class="def-var-arguments">(s,m<sub class="sub">s</sub>,[1,2])</var><a class="copiable-link" href="#index-spin_005fmbra"> &para;</a></span></dt>
<dd><p><code class="code">spin_mbra</code> returns a bra in the <code class="code">z</code>-basis for spin <code class="code">s</code>
and z-projection <code class="code">m<sub class="sub">s</sub></code>, for axis 1=X or 2=Y.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) spin_mket(3/2,1/2,2);
                                [  sqrt(3)   ]
                                [  -------   ]
                                [    3/2     ]
                                [   2        ]
                                [            ]
                                [     %i     ]
                                [    ----    ]
                                [     3/2    ]
                                [    2       ]
(%o1)                           [            ]
                                [     1      ]
                                [    ----    ]
                                [     3/2    ]
                                [    2       ]
                                [            ]
                                [ sqrt(3) %i ]
                                [ ---------- ]
                                [     3/2    ]
                                [    2       ]
(%i2) spin_mbra(1,1,1);
                               [ 1     1     1 ]
(%o2)                          [ -  -------  - ]
                               [ 2  sqrt(2)  2 ]
</pre></div></div>

</div>
</div>
<div class="subsection-level-extent" id="Angular-momentum-_0028j_002cm_0029_002dkets-and-bras">
<h4 class="subsection"><span>1.2.6 Angular momentum (j,m)-kets and bras<a class="copiable-link" href="#Angular-momentum-_0028j_002cm_0029_002dkets-and-bras"> &para;</a></span></h4>

<p>To create kets and bras in the <var class="var">|j,m&gt;</var> representation you use the
abstract <code class="code">ket</code> and <code class="code">bra</code> functions with <code class="code">j,m</code> as
arguments, as in <code class="code">ket([j,m])</code> and <code class="code">bra([j,m])</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) bra([3/2,1/2]);
                                     3  1
(%o1)                               &lt;-, -|
                                     2  2
(%i2) ket([3/2,1/2]);
                                     3  1
(%o2)                               |-, -&gt;
                                     2  2
</pre></div></div>

<p>Some convenience functions for making the kets are the following:
</p>
<a class="anchor" id="jmtop"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmtop"><span class="category-def">Function: </span><span><strong class="def-name">jmtop</strong> <var class="def-var-arguments">(<code class="code">j</code>)</var><a class="copiable-link" href="#index-jmtop"> &para;</a></span></dt>
<dd><p><code class="code">jmtop</code> creates a (j,m)-ket with <code class="code">m=j</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmtop(3/2);
                                     3  3
(%o1)                               |-, -&gt;
                                     2  2
</pre></div></div>

<a class="anchor" id="jmbot"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmbot"><span class="category-def">Function: </span><span><strong class="def-name">jmbot</strong> <var class="def-var-arguments">(<code class="code">j</code>)</var><a class="copiable-link" href="#index-jmbot"> &para;</a></span></dt>
<dd><p><code class="code">jmbot</code> creates a (j,m)-ket with <code class="code">m=-j</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmbot(3/2);
                                    3    3
(%o1)                              |-, - -&gt;
                                    2    2
</pre></div></div>

<a class="anchor" id="jmket"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmket"><span class="category-def">Function: </span><span><strong class="def-name">jmket</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jmket"> &para;</a></span></dt>
<dd><p><code class="code">jmket</code> creates a (j,m)-ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmket(3/2,1/2);
                                     3  1
(%o1)                               |-, -&gt;
                                     2  2
</pre></div></div>

<a class="anchor" id="jmketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmketp"><span class="category-def">Function: </span><span><strong class="def-name">jmketp</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-jmketp"> &para;</a></span></dt>
<dd><p><code class="code">jmketp</code> checks to see that the ket has an <code class="code">m</code>-value that is in
the set <code class="code">{-j,-j+1,&hellip;,+j}</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmketp(ket([j,m]));
(%o1)                                false
(%i2) jmketp(ket([3/2,1/2]));
(%o2)                                true
</pre></div></div>

<a class="anchor" id="jmbrap"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmbrap"><span class="category-def">Function: </span><span><strong class="def-name">jmbrap</strong> <var class="def-var-arguments">(<em class="emph">jmbra</em>)</var><a class="copiable-link" href="#index-jmbrap"> &para;</a></span></dt>
<dd><p><code class="code">jmbrap</code> checks to see that the bra has an <code class="code">m</code>-value that is in
the set <code class="code">{-j,-j+1,&hellip;,+j}</code>.
</p></dd></dl>

<a class="anchor" id="jmcheck"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmcheck"><span class="category-def">Function: </span><span><strong class="def-name">jmcheck</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jmcheck"> &para;</a></span></dt>
<dd><p><code class="code">jmcheck</code> checks to see that <var class="var">m</var> is one of {-j, &hellip;, +j}.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmcheck(3/2,1/2);
(%o1)                                true
</pre></div></div>

<a class="anchor" id="JP"></a><dl class="first-deffn">
<dt class="deffn" id="index-JP"><span class="category-def">Function: </span><span><strong class="def-name">JP</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-JP"> &para;</a></span></dt>
<dd><p><code class="code">JP</code> is the <code class="code">J<sub class="sub">+</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m+1))*hbar*jmket(j,m+1)</code>.
</p></dd></dl>

<a class="anchor" id="JM"></a><dl class="first-deffn">
<dt class="deffn" id="index-JM"><span class="category-def">Function: </span><span><strong class="def-name">JM</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-JM"> &para;</a></span></dt>
<dd><p><code class="code">JM</code> is the <code class="code">J<sub class="sub">-</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m-1))*hbar*jmket(j,m-1)</code>.
</p></dd></dl>

<a class="anchor" id="Jsqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jsqr"><span class="category-def">Function: </span><span><strong class="def-name">Jsqr</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jsqr"> &para;</a></span></dt>
<dd><p><code class="code">Jsqr</code> is the <code class="code">J<sup class="sup">2</sup></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">(j*(j+1)*hbar<sup class="sup">2</sup>*jmket(j,m)</code>.
</p></dd></dl>

<a class="anchor" id="Jz"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jz"><span class="category-def">Function: </span><span><strong class="def-name">Jz</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jz"> &para;</a></span></dt>
<dd><p><code class="code">Jz</code> is the <code class="code">J<sub class="sub">z</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">m*hbar*jmket(j,m)</code>.
</p></dd></dl>

<p>These functions are illustrated below.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([j,m]);
(%o1)                               |j, m&gt;
(%i2) JP(k);
(%o2)             hbar |j, m + 1&gt; sqrt(j (j + 1) - m (m + 1))
(%i3) JM(k);
(%o3)             hbar |j, m - 1&gt; sqrt(j (j + 1) - (m - 1) m)
(%i4) Jsqr(k);
                                2
(%o4)                       hbar  j (j + 1) |j, m&gt;
(%i5) Jz(k);
(%o5)                            hbar |j, m&gt; m
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Addition-of-angular-momentum-in-the-_0028j_002cm_0029_002drepresentation">
<h4 class="subsection"><span>1.2.7 Addition of angular momentum in the (j,m)-representation<a class="copiable-link" href="#Addition-of-angular-momentum-in-the-_0028j_002cm_0029_002drepresentation"> &para;</a></span></h4>

<p>Addition of angular momentum calculations can be performed in the
(j,m)-representation using the function definitions below. The internal
representation of kets and bras for this purpose is the following. Given
kets <code class="code">|j1,m1&gt;</code> and <code class="code">|j2,m2&gt;</code> a tensor product of (j,m)-kets
is instantiated as:
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">[tpket,1,|j1,m1&gt;,|j2,m2&gt;]</code>
</p>
<p>and the corresponding bra is instantiated as:
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">[tpket,1,&lt;j1,m1|,&lt;j2,m2|]</code>
</p>
<p>where the factor of 1 is the multiplicative factor of the tensor
product. We call this the <em class="emph">common factor</em> (cf) of the tensor
product. The general form of a tensor product in the (j,m)
representation is:
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">[tpket, cf, |j1,m1&gt;, |j2,m2&gt;]</code>.
</p>
<p>Using the function definitions below one must be careful to avoid errors
produced by Maxima&rsquo;s automatic list arithmetic. For example, do not
use <code class="code">(J1z+J2z)</code>, and instead use the defined function <code class="code">Jtz</code>.
Similarly for any of the operators that are added together, one should
always use the total <code class="code">Jtxx</code> defined function.
</p>
<a class="anchor" id="tpket"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpket"><span class="category-def">Function: </span><span><strong class="def-name">tpket</strong> <var class="def-var-arguments">(<em class="emph">jmket1,jmket2</em>)</var><a class="copiable-link" href="#index-tpket"> &para;</a></span></dt>
<dd><p><code class="code">tpket</code> instantiates a tensor product of two (j,m)-kets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tpket(ket([3/2,1/2]),ket([1/2,1/2]));
                                      3  1    1  1
(%o1)                     [tpket, 1, |-, -&gt;, |-, -&gt;]
                                      2  2    2  2
</pre></div></div>

<a class="anchor" id="tpbra"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpbra"><span class="category-def">Function: </span><span><strong class="def-name">tpbra</strong> <var class="def-var-arguments">(<em class="emph">jmbra1,jmbra2</em>)</var><a class="copiable-link" href="#index-tpbra"> &para;</a></span></dt>
<dd><p><code class="code">tpbra</code> instantiates a tensor product of two (j,m)-bras.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tpbra(bra([3/2,1/2]),bra([1/2,1/2]));
                                      3  1    1  1
(%o1)                     [tpbra, 1, &lt;-, -|, &lt;-, -|]
                                      2  2    2  2
</pre></div></div>

<a class="anchor" id="tpbraket"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpbraket"><span class="category-def">Function: </span><span><strong class="def-name">tpbraket</strong> <var class="def-var-arguments">(<em class="emph">tpbra,tpket</em>)</var><a class="copiable-link" href="#index-tpbraket"> &para;</a></span></dt>
<dd><p><code class="code">tpbraket</code> returns the bracket of a <code class="code">tpbra</code> and a <code class="code">tpket</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(jmtop(1),jmbot(1));
(%o1)                    [tpket, 1, |1, 1&gt;, |1, - 1&gt;]
(%i2) K:Jtsqr(k);
                    2                                    2
(%o2) [tpket, 2 hbar , |1, 1&gt;, |1, - 1&gt;] + [tpket, 2 hbar , |1, 0&gt;, |1, 0&gt;]
(%i3) B:tpdagger(k);
(%o3)                    [tpbra, 1, &lt;1, 1|, &lt;1, - 1|]
(%i4) tpbraket(B,K);
                                          2
(%o4)                               2 hbar
</pre></div></div>

<a class="anchor" id="tpcfset"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpcfset"><span class="category-def">Function: </span><span><strong class="def-name">tpcfset</strong> <var class="def-var-arguments">(<code class="code">cf</code>,<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-tpcfset"> &para;</a></span></dt>
<dd><p><code class="code">tpcfset</code> manually sets the <em class="emph">common factor</em> <code class="code">cf</code> of a <code class="code">tpket</code>.
</p></dd></dl>

<a class="anchor" id="tpscmult"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpscmult"><span class="category-def">Function: </span><span><strong class="def-name">tpscmult</strong> <var class="def-var-arguments">(<code class="code">a</code>,<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-tpscmult"> &para;</a></span></dt>
<dd><p><code class="code">tpscmult</code> multiplies the tensor product&rsquo;s common factor by <code class="code">a</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                     1  1    1    1
(%o1)                    [tpket, 1, |-, -&gt;, |-, - -&gt;]
                                     2  2    2    2
(%i2) tpscmult(c,k1);
                                     1  1    1    1
(%o2)                    [tpket, c, |-, -&gt;, |-, - -&gt;]
                                     2  2    2    2
</pre></div></div>

<a class="anchor" id="tpadd"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpadd"><span class="category-def">Function: </span><span><strong class="def-name">tpadd</strong> <var class="def-var-arguments">(<em class="emph">tpket,tpket</em>)</var><a class="copiable-link" href="#index-tpadd"> &para;</a></span></dt>
<dd><p><code class="code">tpadd</code> adds two <code class="code">tpket</code>s. This function is necessary
to avoid trouble with Maxima&rsquo;s automatic list arithmetic.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                     1  1    1    1
(%o1)                    [tpket, 1, |-, -&gt;, |-, - -&gt;]
                                     2  2    2    2
(%i2) k2:tpket(ket([1/2,-1/2]),ket([1/2,1/2]));
                                     1    1    1  1
(%o2)                    [tpket, 1, |-, - -&gt;, |-, -&gt;]
                                     2    2    2  2
(%i3) tpadd(k1,k2);
                      1  1    1    1                 1    1    1  1
(%o3)     [tpket, 1, |-, -&gt;, |-, - -&gt;] + [tpket, 1, |-, - -&gt;, |-, -&gt;]
                      2  2    2    2                 2    2    2  2
</pre></div></div>

<a class="anchor" id="tpdagger"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpdagger"><span class="category-def">Function: </span><span><strong class="def-name">tpdagger</strong> <var class="def-var-arguments">(<em class="emph">tpket or tpbra</em>)</var><a class="copiable-link" href="#index-tpdagger"> &para;</a></span></dt>
<dd><p><code class="code">tpdagger</code> takes the quantum mechanical dagger of a <code class="code">tpket</code> or <code class="code">tpbra</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                     1  1    1    1
(%o1)                    [tpket, 1, |-, -&gt;, |-, - -&gt;]
                                     2  2    2    2
(%i2) tpdagger(k1);
                                     1  1    1    1
(%o2)                    [tpbra, 1, &lt;-, -|, &lt;-, - -|]
                                     2  2    2    2
</pre></div></div>

<a class="anchor" id="J1z"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1z"><span class="category-def">Function: </span><span><strong class="def-name">J1z</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1z"> &para;</a></span></dt>
<dd><p><code class="code">J1z</code> returns the tensor product of a tpket with <code class="code">Jz</code> acting
on the first ket.
</p></dd></dl>

<a class="anchor" id="J2z"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2z"><span class="category-def">Function: </span><span><strong class="def-name">J2z</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2z"> &para;</a></span></dt>
<dd><p><code class="code">J2z</code> returns the tensor product of a tpket with <code class="code">Jz</code> acting
on the second ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,3/2]),ket([1/2,1/2]));
                                      3  3    1  1
(%o1)                     [tpket, 1, |-, -&gt;, |-, -&gt;]
                                      2  2    2  2
(%i2) J1z(k);
                                3 hbar   3  3    1  1
(%o2)                   [tpket, ------, |-, -&gt;, |-, -&gt;]
                                  2      2  2    2  2
(%i3) J2z(k);
                                 hbar   3  3    1  1
(%o3)                    [tpket, ----, |-, -&gt;, |-, -&gt;]
                                  2     2  2    2  2
</pre></div></div>

<a class="anchor" id="Jtz"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtz"><span class="category-def">Function: </span><span><strong class="def-name">Jtz</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtz"> &para;</a></span></dt>
<dd><p><code class="code">Jtz</code> is the total z-projection of spin operator acting on a tpket
and returning <code class="code">(J<sub class="sub">1z</sub>+J<sub class="sub">2z</sub>)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,3/2]),ket([1/2,1/2]));
                                      3  3    1  1
(%o1)                     [tpket, 1, |-, -&gt;, |-, -&gt;]
                                      2  2    2  2
(%i2) Jtz(k);
                                         3  3    1  1
(%o2)                   [tpket, 2 hbar, |-, -&gt;, |-, -&gt;]
                                         2  2    2  2
</pre></div></div>

<a class="anchor" id="J1sqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1sqr"><span class="category-def">Function: </span><span><strong class="def-name">J1sqr</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1sqr"> &para;</a></span></dt>
<dd><p><code class="code">J1sqr</code> returns <code class="code">Jsqr</code> for the first ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J2sqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2sqr"><span class="category-def">Function: </span><span><strong class="def-name">J2sqr</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2sqr"> &para;</a></span></dt>
<dd><p><code class="code">J2sqr</code> returns <code class="code">Jsqr</code> for the second ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J1p"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1p"><span class="category-def">Function: </span><span><strong class="def-name">J1p</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1p"> &para;</a></span></dt>
<dd><p><code class="code">J1p</code> returns <code class="code">J<sub class="sub">+</sub></code> for the first ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J2p"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2p"><span class="category-def">Function: </span><span><strong class="def-name">J2p</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2p"> &para;</a></span></dt>
<dd><p><code class="code">J2p</code> returns <code class="code">J<sub class="sub">+</sub></code> for the second ket of a tpket.
</p></dd></dl>

<a class="anchor" id="Jtp"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtp"><span class="category-def">Function: </span><span><strong class="def-name">Jtp</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtp"> &para;</a></span></dt>
<dd><p><code class="code">Jtp</code> returns <code class="code">(J<sub class="sub">1+</sub>+J<sub class="sub">2+</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="J1m"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1m"><span class="category-def">Function: </span><span><strong class="def-name">J1m</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1m"> &para;</a></span></dt>
<dd><p><code class="code">J1m</code> returns <code class="code">J<sub class="sub">-</sub></code> for the first ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J2m"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2m"><span class="category-def">Function: </span><span><strong class="def-name">J2m</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2m"> &para;</a></span></dt>
<dd><p><code class="code">J2m</code> returns <code class="code">J<sub class="sub">=</sub></code> for the second ket of a tpket.
</p></dd></dl>

<a class="anchor" id="Jtm"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtm"><span class="category-def">Function: </span><span><strong class="def-name">Jtm</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtm"> &para;</a></span></dt>
<dd><p><code class="code">Jtm</code> returns <code class="code">(J<sub class="sub">1-</sub>+J<sub class="sub">2-</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="J1p2m"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1p2m"><span class="category-def">Function: </span><span><strong class="def-name">J1p2m</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1p2m"> &para;</a></span></dt>
<dd><p><code class="code">J1p2m</code> returns <code class="code">(J<sub class="sub">1+</sub>J<sub class="sub">2-</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="J1m2p"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1m2p"><span class="category-def">Function: </span><span><strong class="def-name">J1m2p</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1m2p"> &para;</a></span></dt>
<dd><p><code class="code">J1m2p</code> returns <code class="code">(J<sub class="sub">1-</sub>J<sub class="sub">2+</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="J1zJ2z"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1zJ2z"><span class="category-def">Function: </span><span><strong class="def-name">J1zJ2z</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1zJ2z"> &para;</a></span></dt>
<dd><p><code class="code">J1zJ2z</code> returns <code class="code">(J<sub class="sub">1z</sub>J<sub class="sub">2z</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="Jtsqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtsqr"><span class="category-def">Function: </span><span><strong class="def-name">Jtsqr</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtsqr"> &para;</a></span></dt>
<dd><p><code class="code">Jtsqr</code> returns <code class="code">(J<sub class="sub">1</sub><sup class="sup">2</sup>+J<sub class="sub">2</sub><sup class="sup">2</sup>+
J<sub class="sub">1+</sub>J<sub class="sub">2-</sub>+J<sub class="sub">1-</sub>J<sub class="sub">2+</sub>+J<sub class="sub">1z</sub>J<sub class="sub">2z</sub>)</code> for the
tpket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,1/2]),ket([1/2,1/2]));
                                      3  1    1  1
(%o1)                     [tpket, 1, |-, -&gt;, |-, -&gt;]
                                      2  2    2  2
(%i2) b:tpdagger(k);
                                      3  1    1  1
(%o2)                     [tpbra, 1, &lt;-, -|, &lt;-, -|]
                                      2  2    2  2
(%i3) J1p2m(k);
                                       2   3  3    1    1
(%o3)              [tpket, sqrt(3) hbar , |-, -&gt;, |-, - -&gt;]
                                           2  2    2    2
(%i4) J1m2p(k);
(%o4)                                  0
</pre></div><div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,-1/2]),ket([1/2,1/2]));
                                     3    1    1  1
(%o1)                    [tpket, 1, |-, - -&gt;, |-, -&gt;]
                                     2    2    2  2
(%i2) B:tpdagger(k);
                                     3    1    1  1
(%o2)                    [tpbra, 1, &lt;-, - -|, &lt;-, -|]
                                     2    2    2  2
(%i3) K2:Jtsqr(k);
                    2   3    1    1  1                   2   3  1    1    1
(%o3) [tpket, 4 hbar , |-, - -&gt;, |-, -&gt;] + [tpket, 2 hbar , |-, -&gt;, |-, - -&gt;]
                        2    2    2  2                       2  2    2    2
(%i4) tpbraket(B,K2);
                                          2
(%o4)                               4 hbar
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Explicit-computations" accesskey="1">Explicit computations</a></li>
</ul>
<div class="subsubsection-level-extent" id="Explicit-computations">
<h4 class="subsubsection"><span>1.2.7.1 Explicit computations<a class="copiable-link" href="#Explicit-computations"> &para;</a></span></h4>

<p>For the first example, let us see how to determine the total spin state
<code class="code">|j,m&gt;</code> of the two-particle state <code class="code">|1/2,1/2;1,1&gt;</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(jmtop(1/2),jmtop(1));
                                      1  1
(%o1)                     [tpket, 1, |-, -&gt;, |1, 1&gt;]
                                      2  2
(%i2) Jtsqr(k);
                                      2
                               15 hbar    1  1
(%o2)                  [tpket, --------, |-, -&gt;, |1, 1&gt;]
                                  4       2  2
(%i3) get_j(15/4);
                                         3
(%o3)                                j = -
                                         2
</pre></div></div>

<p>This is an eigenket of <code class="code">Jtsqr</code>, thus <code class="code">|3/2,3/2&gt; =
|1/2,1/2;1,1&gt;</code>, and it is also the top state. One can now apply the
lowering operator to find the other states: <code class="code">|3/2,1/2&gt;</code>,
<code class="code">|3/2,-1/2&gt;</code>, and <code class="code">|3/2,-3/2&gt;</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(jmtop(1/2),jmtop(1));
                                      1  1
(%o1)                     [tpket, 1, |-, -&gt;, |1, 1&gt;]
                                      2  2
(%i2) k2:Jtm(k);
                             1  1                            1    1
(%o2) [tpket, sqrt(2) hbar, |-, -&gt;, |1, 0&gt;] + [tpket, hbar, |-, - -&gt;, |1, 1&gt;]
                             2  2                            2    2
(%i3) k3:Jtm(k2);
               3/2     2   1    1
(%o3) [tpket, 2    hbar , |-, - -&gt;, |1, 0&gt;]
                           2    2
                                                           2   1  1
                                           + [tpket, 2 hbar , |-, -&gt;, |1, - 1&gt;]
                                                               2  2
(%i4) k4:Jtm(k3);
                    3   1    1
(%o4) [tpket, 4 hbar , |-, - -&gt;, |1, - 1&gt;]
                        2    2
                                                         3   1    1
                                         + [tpket, 2 hbar , |-, - -&gt;, |1, - 1&gt;]
                                                             2    2
</pre></div></div>

<p>Let us see how to compute the matrix elements of the operator
<code class="code">(J1z-J1z)</code> in the z-basis for two spin-1/2 particles. Note that we
use the <code class="code">tpadd</code> and <code class="code">tpscmult</code> functions to add the two
operators. First, we form the four basis kets
<code class="code">{phi<sub class="sub">1</sub>,phi<sub class="sub">2</sub>,phi<sub class="sub">3</sub>,phi<sub class="sub">4</sub>}</code> of the form
<code class="code">|j<sub class="sub">1</sub>,m<sub class="sub">1</sub>;j<sub class="sub">2</sub>,m<sub class="sub">2</sub>&gt;</code>. The next four entries are
for the operator acting on the basis kets. We skip taking the braket
below; the common factor is the resulting matrix element.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) phi1:tpket(ket([1/2,1/2]),ket([1/2,1/2]));
                                      1  1    1  1
(%o1)                     [tpket, 1, |-, -&gt;, |-, -&gt;]
                                      2  2    2  2
(%i2) phi2:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                     1  1    1    1
(%o2)                    [tpket, 1, |-, -&gt;, |-, - -&gt;]
                                     2  2    2    2
(%i3) phi3:tpket(ket([1/2,-1/2]),ket([1/2,1/2]));
                                     1    1    1  1
(%o3)                    [tpket, 1, |-, - -&gt;, |-, -&gt;]
                                     2    2    2  2
(%i4) phi4:tpket(ket([1/2,-1/2]),ket([1/2,-1/2]));
                                    1    1    1    1
(%o4)                   [tpket, 1, |-, - -&gt;, |-, - -&gt;]
                                    2    2    2    2
(%i5) tpadd(J1z(phi1),tpscmult(-1,J2z(phi1)));
(%o5)                                  0
(%i6) tpadd(J1z(phi2),tpscmult(-1,J2z(phi2)));
                                       1  1    1    1
(%o6)                   [tpket, hbar, |-, -&gt;, |-, - -&gt;]
                                       2  2    2    2
(%i7) tpadd(J1z(phi3),tpscmult(-1,J2z(phi3)));
                                        1    1    1  1
(%o7)                  [tpket, - hbar, |-, - -&gt;, |-, -&gt;]
                                        2    2    2  2
(%i8) tpadd(J1z(phi4),tpscmult(-1,J2z(phi4)));
(%o8)                                  0
</pre></div></div>

</div>
</div>
<div class="subsection-level-extent" id="Angular-momentum-and-ladder-operators">
<h4 class="subsection"><span>1.2.8 Angular momentum and ladder operators<a class="copiable-link" href="#Angular-momentum-and-ladder-operators"> &para;</a></span></h4>

<a class="anchor" id="SP"></a><dl class="first-deffn">
<dt class="deffn" id="index-SP"><span class="category-def">Function: </span><span><strong class="def-name">SP</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SP"> &para;</a></span></dt>
<dd><p><code class="code">SP</code> is the raising ladder operator <var class="var">S<sub class="sub">+</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<a class="anchor" id="SM"></a><dl class="first-deffn">
<dt class="deffn" id="index-SM"><span class="category-def">Function: </span><span><strong class="def-name">SM</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SM"> &para;</a></span></dt>
<dd><p><code class="code">SM</code> is the raising ladder operator <var class="var">S<sub class="sub">-</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<p>Examples of the ladder operators:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SP(1);
                       [ 0  sqrt(2) hbar       0       ]
                       [                               ]
(%o1)                  [ 0       0        sqrt(2) hbar ]
                       [                               ]
                       [ 0       0             0       ]
(%i2) SM(1);
                       [      0             0        0 ]
                       [                               ]
(%o2)                  [ sqrt(2) hbar       0        0 ]
                       [                               ]
                       [      0        sqrt(2) hbar  0 ]
</pre></div></div>

</div>
</div>
<div class="section-level-extent" id="Rotation-operators">
<h3 class="section"><span>1.3 Rotation operators<a class="copiable-link" href="#Rotation-operators"> &para;</a></span></h3>

<a class="anchor" id="RX"></a><dl class="first-deffn">
<dt class="deffn" id="index-RX"><span class="category-def">Function: </span><span><strong class="def-name">RX</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RX"> &para;</a></span></dt>
<dd><p><code class="code">RX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rx</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<a class="anchor" id="RY"></a><dl class="first-deffn">
<dt class="deffn" id="index-RY"><span class="category-def">Function: </span><span><strong class="def-name">RY</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RY"> &para;</a></span></dt>
<dd><p><code class="code">RY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Ry</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<a class="anchor" id="RZ"></a><dl class="first-deffn">
<dt class="deffn" id="index-RZ"><span class="category-def">Function: </span><span><strong class="def-name">RZ</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RZ"> &para;</a></span></dt>
<dd><p><code class="code">RZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rz</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) RY(1,t);
Proviso: assuming 4*t # 0 
                     [ cos(t) + 1    sin(t)   1 - cos(t) ]
                     [ ----------  - -------  ---------- ]
                     [     2         sqrt(2)      2      ]
                     [                                   ]
                     [  sin(t)                  sin(t)   ]
(%o1)                [  -------     cos(t)    - -------  ]
                     [  sqrt(2)                 sqrt(2)  ]
                     [                                   ]
                     [ 1 - cos(t)   sin(t)    cos(t) + 1 ]
                     [ ----------   -------   ---------- ]
                     [     2        sqrt(2)       2      ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Time_002devolution-operator">
<h3 class="section"><span>1.4 Time-evolution operator<a class="copiable-link" href="#Time_002devolution-operator"> &para;</a></span></h3>

<a class="anchor" id="UU"></a><dl class="first-deffn">
<dt class="deffn" id="index-UU"><span class="category-def">Function: </span><span><strong class="def-name">UU</strong> <var class="def-var-arguments">(<code class="code">H,t</code>)</var><a class="copiable-link" href="#index-UU"> &para;</a></span></dt>
<dd><p><code class="code">UU(H,t)</code> is the time evolution operator for Hamiltonian <code class="code">H</code>. It
is defined as the matrix exponential <code class="code">matrixexp(-%i*H*t/hbar)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) UU(w*Sy,t);
Proviso: assuming 64*t*w # 0 
                           [     t w         t w  ]
                           [ cos(---)  - sin(---) ]
                           [      2           2   ]
(%o1)                      [                      ]
                           [     t w        t w   ]
                           [ sin(---)   cos(---)  ]
                           [      2          2    ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Tensor-products">
<h3 class="section"><span>1.5 Tensor products<a class="copiable-link" href="#Tensor-products"> &para;</a></span></h3>

<p>Tensor products are represented as lists in the <code class="code">qm</code> package. The
ket tensor product <code class="code">|z+,z+&gt;</code> can be represented as
<code class="code">ket([u,d])</code>, for example, and the bra tensor product <code class="code">&lt;a,b|</code>
is represented as <code class="code">bra([a,b])</code> for states <code class="code">a</code> and
<code class="code">b</code>. For a tensor product where the identity is one of the elements
of the product, substitute the string <code class="code">Id</code> in the ket or bra at the
desired location. See the examples below for the use of the identity in
tensor products.
</p>
<p>Examples below show how to create abstract tensor products that contain
the identity element <code class="code">Id</code> and how to take the bracket of these
tensor products.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) K:ket([a1,b1]);
(%o1)                              |a1, b1&gt;
(%i2) B:bra([a2,b2]);
(%o2)                              &lt;a2, b2|
(%i3) braket(B,K);
(%o3)                kron_delta(a1, a2) kron_delta(b1, b2)
</pre></div><div class="group"><pre class="example-preformatted">(%i1) bra([a1,Id,c1]) . ket([a2,b2,c2]);
(%o1)          |-, b2, -&gt; kron_delta(a1, a2) kron_delta(c1, c2)
(%i2) bra([a1,b1,c1]) . ket([Id,b2,c2]);
(%o2)          &lt;a1, -, -| kron_delta(b1, b2) kron_delta(c1, c2)
</pre></div></div>

<p>In the next example we construct the state function for an entangled
Bell pair, construct the density matrix, and then trace over the first
particle to obtain the density submatrix for particle 2.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) bell:(1/sqrt(2))*(ket([u,d])-ket([d,u]));
                                |u, d&gt; - |d, u&gt;
(%o1)                           ---------------
                                    sqrt(2)
(%i2) rho:bell . dagger(bell);
      |u, d&gt; . &lt;u, d| - |u, d&gt; . &lt;d, u| - |d, u&gt; . &lt;u, d| + |d, u&gt; . &lt;d, u|
(%o2) ---------------------------------------------------------------------
                                        2
(%i3) assume(not equal(u,d));
(%o3)                          [notequal(u, d)]
(%i4) trace1:bra([u,Id]) . rho . ket([u,Id])+bra([d,Id]) . rho . ket([d,Id]);
                       |-, u&gt; . &lt;-, u|   |-, d&gt; . &lt;-, d|
(%o4)                  --------------- + ---------------
                              2                 2
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Quantum-harmonic-oscillator" accesskey="1">Quantum harmonic oscillator</a></li>
</ul>
<div class="subsection-level-extent" id="Quantum-harmonic-oscillator">
<h4 class="subsection"><span>1.5.1 Quantum harmonic oscillator<a class="copiable-link" href="#Quantum-harmonic-oscillator"> &para;</a></span></h4>

<p>The <code class="code">qm</code> package can perform simple quantum harmonic oscillator
calculations involving the ladder operators <code class="code">a<sup class="sup">+</sup></code> and
<code class="code">a<sup class="sup">-</sup></code>. These are referred to in the package as <code class="code">ap</code> and
<code class="code">am</code> respectively. For computations with arbitrary states to work
you must <code class="code">declare</code> the harmonic oscillator state, say <code class="code">n</code>, to
be both <code class="code">scalar</code> and <code class="code">integer</code>, as shown in the examples
below.
</p>
<a class="anchor" id="ap"></a><dl class="first-deffn">
<dt class="deffn" id="index-ap"><span class="category-def">Function: </span><span><strong class="def-name">ap</strong><a class="copiable-link" href="#index-ap"> &para;</a></span></dt>
<dd><p><code class="code">ap</code> is the raising operator <code class="code">a<sup class="sup">+</sup></code> for quantum harmonic
oscillator states.
</p></dd></dl>

<a class="anchor" id="am"></a><dl class="first-deffn">
<dt class="deffn" id="index-am"><span class="category-def">Function: </span><span><strong class="def-name">am</strong><a class="copiable-link" href="#index-am"> &para;</a></span></dt>
<dd><p><code class="code">a</code> is the lowering operator <code class="code">a<sup class="sup">-</sup></code> for quantum harmonic
oscillator states.
</p></dd></dl>

<p>A common problem is to compute the 1st order change in energy of a state
due to a perturbation of the harmonic potential, say an additional
factor <code class="code">V(x) = x^2 + g*x^4</code> for small <code class="code">g</code>. This example is
performed below, ignoring any physical constants in the problem.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare(n,integer,n,scalar);
(%o1)                                done
(%i2) ap . ket([n]);
(%o2)                         sqrt(n + 1) |n + 1&gt;
(%i3) am . ket([n]);
(%o3)                           |n - 1&gt; sqrt(n)
(%i4) bra([n]) . (ap+am)^^4 . ket([n]);
                                   2
(%o4)                           6 n  + 6 n + 3
</pre></div></div>

<br>
<p>Another package that handles quantum mechanical operators is
<code class="code">operator_algebra</code> written by Barton Willis.
</p>
</div>
</div>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
