<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Top (Package qm)</title>

<meta name="description" content="Top (Package qm)">
<meta name="keywords" content="Top (Package qm)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#Top" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="../dir_html/index.html" rel="up" title="(dir)">
<link href="#Introduction-to-package-qm" rel="next" title="Introduction to package qm">
<link href="../dir_html/index.html" rel="prev" title="(dir)">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">



<div class="top-level-extent" id="Top">
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<a class="top" id="SEC_Top"></a>


<ul class="mini-toc">
<li><a href="#Package-qm" accesskey="1">Package qm</a></li>
<li><a href="Function-and-Variable-Index.html" accesskey="2">Function and Variable index</a></li>
</ul>
<div class="chapter-level-extent" id="Package-qm">
<h2 class="chapter"><span>1 Package qm<a class="copiable-link" href="#Package-qm"> &para;</a></span></h2>

<ul class="mini-toc">
<li><a href="#Introduction-to-package-qm" accesskey="1">Introduction to package qm</a></li>
<li><a href="#Functions-and-Variables-for-qm" accesskey="2">Functions and Variables for qm</a></li>
<li><a href="#Rotation-operators" accesskey="3">Rotation operators</a></li>
<li><a href="#Time_002devolution-operator" accesskey="4">Time-evolution operator</a></li>
<li><a href="#Tensor-products" accesskey="5">Tensor products</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-package-qm">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-qm" accesskey="n" rel="next">Functions and Variables for qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-package-qm-1"><span>1.1 Introduction to package qm<a class="copiable-link" href="#Introduction-to-package-qm-1"> &para;</a></span></h3>

<p>The <code class="code">qm</code> package was written by Eric Majzoub, University of
Missouri. Email: majzoube-at-umsystem.edu
</p>
<p>The package is loaded with: <code class="code">load(qm);</code>
</p>
<p>NOTE!! <em class="emph">The code base is under very active development. Behavior
related to tensor product states is being updated and the package
behavior is likely to change or be in an unstable state.</em>
</p>
<p>The <code class="code">qm</code> package provides functions and standard definitions to
solve quantum mechanics problems in a finite dimensional Hilbert
space. For example, one can calculate the outcome of Stern-Gerlach
experiments using the built-in definition of the Sx, Sy, and Sz
operators for arbitrary spin, e.g. <code class="code">s={1/2, 1, 3/2,
&hellip;}</code>. For spin-1/2 the standard basis states in the <code class="code">x</code>,
<code class="code">y</code>, and <code class="code">z</code>-basis are available as <code class="code">{xp,xm}</code>,
<code class="code">{yp,ym}</code>, and <code class="code">{zp,zm}</code>, respectively. One can create
general ket vectors with arbitrary but finite dimension and perform
standard computations such as expectation value, variance, etc. The
angular momentum <var class="var">|j,m&gt;</var> representation of kets is also
available. It is also possible to create tensor product states for
multiparticle systems and to perform calculations on those systems.
</p>
<p>Let us consider a simple example involving spin-1/2 particles.
A bra vector in the <code class="code">z</code>-basis may be written as 
</p>
<p><code class="code">&lt;psi| = a &lt;z+| + b &lt;z-|</code>.
</p>
<p>The bra will be represented in Maxima by the row vector <code class="code">[a b]</code>,
where the basis vectors are
</p>
<p><code class="code">&lt;z+| = [1 0]</code>
</p>
<p>and
</p>
<p><code class="code">&lt;z-| = [0 1]</code>.
</p>
<p>There are two types of kets and bras available in this package, the
first type is given by a <em class="emph">matrix representation</em>, as in the above
example. <code class="code">mket</code>s are column vectors and <code class="code">mbra</code>s are row
vectors, and their components are entered as Maxima <em class="emph">lists</em> in the
<code class="code">mbra</code> and <code class="code">mket</code> functions. The second type of bra or ket is
<em class="emph">abstract</em>; there is no matrix representation. Abstract bras and
kets are entered using the <code class="code">bra</code> and <code class="code">ket</code> functions using
lists for the elements. These general kets are displayed in Dirac
notation. Note that abstract kets and bras are <em class="emph">assumed to be
orthonormal</em>.
</p>
<p>The following examples illustrate some of the basic capabilities of the
<code class="code">qm</code> package. Here both abstract, and concrete kets are shown.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ket([a,b])+ket([c,d]);
(%o1)                         |[c, d]&gt; + |[a, b]&gt;
(%i2) mket([a,b])+mket([c,d]);
                                   [ c + a ]
(%o2)                              [       ]
                                   [ d + b ]
</pre></div></div>

<p>Note that <code class="code">ket([a,b])</code> is treated as tensor product of states
<code class="code">a</code> and <code class="code">b</code> as shown below. Tensor product states
within the matrix representation are described in the section
on tensor product states.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) braket(bra([a1,b1]),ket([a2,b2]));
(%o1)                kron_delta(a1, a2) kron_delta(b1, b2)
</pre></div></div>

<p>Next, tensor products of the spin-1/2 basis states <code class="code">{zp,zm}</code> are
shown in abstract and matrix representations.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tpket('zp,'zm)+tpket('zm,'zp);
(%o1)                    tpket(zp, zm) + tpket(zm, zp)
(%i2) tpket([zp,zm]);
                                     [ 1 ]  [ 0 ]
(%o2)                       [tpket, [[   ], [   ]]]
                                     [ 0 ]  [ 1 ]
</pre></div></div>

<p>Abstract kets and bras are assumed to be orthonormal as shown below.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:a*ket([1])+b*ket([2]);
(%o2)                          |[2]&gt; b + |[1]&gt; a
(%i3) psidag:dagger(psi);
(%o3)               &lt;[2]| conjugate(b) + &lt;[1]| conjugate(a)
(%i4) psidag . psi;
(%o4)                   b conjugate(b) + a conjugate(a)
</pre></div></div>

<p>The following shows how to declare a ket with both real and
complex components in the matrix representation.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([c1,c2],complex,r,real);
(%o1)                                done
(%i2) k:mket([c1,c2,r]);
                                    [ c1 ]
                                    [    ]
(%o2)                               [ c2 ]
                                    [    ]
                                    [ r  ]
(%i3) b:dagger(k);
(%o3)                 [ conjugate(c1)  conjugate(c2)  r ]
(%i4) b . k;
                    2
(%o4)              r  + c2 conjugate(c2) + c1 conjugate(c1)
</pre></div></div>

<hr>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-qm">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-package-qm" accesskey="p" rel="prev">Introduction to package qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-qm-1"><span>1.2 Functions and Variables for qm<a class="copiable-link" href="#Functions-and-Variables-for-qm-1"> &para;</a></span></h3>

<dl class="first-defvr">
<dt class="defvr" id="index-hbar"><span class="category-def">Variable: </span><span><strong class="def-name">hbar</strong><a class="copiable-link" href="#index-hbar"> &para;</a></span></dt>
<dd><p>Planck&rsquo;s constant divided by <code class="code">2*%pi</code>. <code class="code">hbar</code> is not given a
floating point value, but is declared to be a real number greater than
zero.
</p></dd></dl>

<a class="anchor" id="mket"></a><dl class="first-deffn">
<dt class="deffn" id="index-mket"><span class="category-def">Function: </span><span><strong class="def-name">mket</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-mket"> &para;</a></span></dt>
<dd><p><code class="code">mket</code> creates a <em class="emph">column</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex. For a
matrix representation the elements must be entered as a list in
<code class="code">[&hellip;]</code> square brackets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([c1,c2],complex);
(%o1)                                done
(%i2) mket([c1,c2]);
                                    [ c1 ]
(%o2)                               [    ]
                                    [ c2 ]
(%i3) facts();
(%o3) [kind(hbar, real), hbar &gt; 0, kind(c1, complex), kind(c2, complex)]
</pre></div></div>

<a class="anchor" id="mbra"></a><dl class="first-deffn">
<dt class="deffn" id="index-mbra"><span class="category-def">Function: </span><span><strong class="def-name">mbra</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-mbra"> &para;</a></span></dt>
<dd><p><code class="code">mbra</code> creates a <em class="emph">row</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex.
For a matrix representation the elements must be entered as a list
in <code class="code">[&hellip;]</code> square brackets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) kill(c1,c2);
(%o1)                                done
(%i2) mbra([c1,c2]);
(%o2)                             [ c1  c2 ]
(%i3) facts();
(%o3)                    [kind(hbar, real), hbar &gt; 0]
</pre></div></div>

<a class="anchor" id="mketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-mketp"><span class="category-def">Function: </span><span><strong class="def-name">mketp</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-mketp"> &para;</a></span></dt>
<dd><p><code class="code">mketp</code> is a predicate function that checks if its input is an mket,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">mketp</code> only returns <code class="code">true</code> for the matrix representation of a ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([a,b]);
(%o1)                              |[a, b]&gt;
(%i2) mketp(k);
(%o2)                                false
(%i3) k:mket([a,b]);
                                     [ a ]
(%o3)                                [   ]
                                     [ b ]
(%i4) mketp(k);
(%o4)                                true
</pre></div></div>

<a class="anchor" id="mbrap"></a><dl class="first-deffn">
<dt class="deffn" id="index-mbrap"><span class="category-def">Function: </span><span><strong class="def-name">mbrap</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-mbrap"> &para;</a></span></dt>
<dd><p><code class="code">mbrap</code> is a predicate function that checks if its input is an mbra,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">mbrap</code> only returns <code class="code">true</code> for the matrix representation of a bra.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) b:mbra([a,b]);
(%o1)                              [ a  b ]
(%i2) mbrap(b);
(%o2)                                true
</pre></div></div>

<p>Two additional functions are provided to create kets and bras in the
matrix representation. Additionally these functions attempt to
automatically <code class="code">declare</code> constants as complex. For example, if a
list entry is <code class="code">a*sin(x)+b*cos(x)</code> then only <code class="code">a</code> and <code class="code">b</code>
will be <code class="code">declare</code>-d complex and not <code class="code">x</code>.
</p>
<a class="anchor" id="autoket"></a><dl class="first-deffn">
<dt class="deffn" id="index-autoket"><span class="category-def">Function: </span><span><strong class="def-name">autoket</strong> <var class="def-var-arguments">([<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>])</var><a class="copiable-link" href="#index-autoket"> &para;</a></span></dt>
<dd><p><code class="code">autoket</code> takes a list [<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>] and
returns a ket with the coefficients <code class="code">a<sub class="sub">i</sub></code> <code class="code">declare</code>-d
complex. Simple expressions such as <code class="code">a*sin(x)+b*cos(x)</code> are allowed
and will <code class="code">declare</code> only the coefficients as complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) autoket([a,b]);
                                     [ a ]
(%o1)                                [   ]
                                     [ b ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) autoket([a*sin(x),b*sin(x)]);
                                 [ a sin(x) ]
(%o1)                            [          ]
                                 [ b sin(x) ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div></div>

<a class="anchor" id="autobra"></a><dl class="first-deffn">
<dt class="deffn" id="index-autobra"><span class="category-def">Function: </span><span><strong class="def-name">autobra</strong> <var class="def-var-arguments">([<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>])</var><a class="copiable-link" href="#index-autobra"> &para;</a></span></dt>
<dd><p><code class="code">autobra</code> takes a list [<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>] and
returns a bra with the coefficients <code class="code">a<sub class="sub">i</sub></code> <code class="code">declare</code>-d
complex. Simple expressions such as <code class="code">a*sin(x)+b*cos(x)</code> are allowed
and will <code class="code">declare</code> only the coefficients as complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) autobra([a,b]);
(%o1)                              [ a  b ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) autobra([a*sin(x),b]);
(%o1)                           [ a sin(x)  b ]
(%i2) facts();
(%o2)  [kind(hbar, real), hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div></div>

<a class="anchor" id="dagger"></a><dl class="first-deffn">
<dt class="deffn" id="index-dagger"><span class="category-def">Function: </span><span><strong class="def-name">dagger</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-dagger"> &para;</a></span></dt>
<dd><p><code class="code">dagger</code> is the quantum mechanical <em class="emph">dagger</em> function and returns
the <code class="code">conjugate</code> <code class="code">transpose</code> of its input.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dagger(mbra([%i,2]));
                                   [ - %i ]
(%o1)                              [      ]
                                   [  2   ]
</pre></div></div>

<a class="anchor" id="braket"></a><dl class="first-deffn">
<dt class="deffn" id="index-braket"><span class="category-def">Function: </span><span><strong class="def-name">braket</strong> <var class="def-var-arguments">(<code class="code">psi,phi</code>)</var><a class="copiable-link" href="#index-braket"> &para;</a></span></dt>
<dd><p>Given two kets <code class="code">psi</code> and <code class="code">phi</code>, <code class="code">braket</code> returns the
quantum mechanical bracket <code class="code">&lt;psi|phi&gt;</code>. The vector <code class="code">psi</code> may be
input as either a <code class="code">ket</code> or <code class="code">bra</code>. If it is a <code class="code">ket</code> it will be
turned into a <code class="code">bra</code> with the <code class="code">dagger</code> function before the inner
product is taken. The vector <code class="code">phi</code> must always be a <code class="code">ket</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) braket(mket([a,b,c]),mket([a,b,c]));
(%o2)          c conjugate(c) + b conjugate(b) + a conjugate(a)
(%i3) braket(ket([a1,b1,c1]),ket([a2,b2,c2]));
(%o3)               braket(|[a1, b1, c1]&gt;, |[a2, b2, c2]&gt;)
</pre></div></div>

<a class="anchor" id="norm"></a><dl class="first-deffn">
<dt class="deffn" id="index-norm"><span class="category-def">Function: </span><span><strong class="def-name">norm</strong> <var class="def-var-arguments">(<code class="code">psi</code>)</var><a class="copiable-link" href="#index-norm"> &para;</a></span></dt>
<dd><p>Given a <code class="code">ket</code> or <code class="code">bra</code> <code class="code">psi</code>, <code class="code">norm</code> returns the
square root of the quantum mechanical bracket <code class="code">&lt;psi|psi&gt;</code>.
The vector <code class="code">psi</code> must always be a <code class="code">ket</code>, otherwise the
function will return <code class="code">false</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) norm(ket([a,b,c]));
(%o2)                          norm(|[a, b, c]&gt;)
(%i3) norm(ket(a,b,c));
(%o3)                           norm(|a, b, c&gt;)
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-magsqr"><span class="category-def">Function: </span><span><strong class="def-name">magsqr</strong> <var class="def-var-arguments">(<code class="code">c</code>)</var><a class="copiable-link" href="#index-magsqr"> &para;</a></span></dt>
<dd><p><code class="code">magsqr</code> returns <code class="code">conjugate(c)*c</code>, the magnitude
squared of a complex number.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c,d],complex);
(%o1)                                done
(%i2) A:braket(ket([a,b]),ket([c,d]));
(%o2)                     braket(|[a, b]&gt;, |[c, d]&gt;)
(%i3) P:magsqr(A);
(%o3)  braket(|[a, b]&gt;, |[c, d]&gt;) conjugate(braket(|[a, b]&gt;, |[c, d]&gt;))
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Handling-general-kets-and-bras" accesskey="1">Handling general kets and bras</a></li>
<li><a href="#Spin_002d1_002f2-state-kets-and-associated-operators" accesskey="2">Spin-1/2 state kets and associated operators</a></li>
<li><a href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators" accesskey="3">Pauli matrices and Sz, Sx, Sy operators</a></li>
<li><a href="#SX_002c-SY_002c-SZ-operators-for-any-spin" accesskey="4">SX, SY, SZ operators for any spin</a></li>
<li><a href="#Expectation-value-and-variance" accesskey="5">Expectation value and variance</a></li>
<li><a href="#Angular-momentum-representation-of-kets-and-bras" accesskey="6">Angular momentum representation of kets and bras</a></li>
<li><a href="#Angular-momentum-and-ladder-operators" accesskey="7">Angular momentum and ladder operators</a></li>
</ul>
<div class="subsection-level-extent" id="Handling-general-kets-and-bras">
<h4 class="subsection"><span>1.2.1 Handling general kets and bras<a class="copiable-link" href="#Handling-general-kets-and-bras"> &para;</a></span></h4>

<p>General kets and bras are, as discussed, created without using a list
when giving the arguments. The following examples show how general
kets and bras can be manipulated.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ket([a])+ket([b]);
(%o1)                            |[b]&gt; + |[a]&gt;
(%i2) braket(bra([a]),ket([b]));
(%o2)                          kron_delta(a, b)
(%i3) braket(bra([a])+bra([c]),ket([b]));
(%o3)                 kron_delta(b, c) + kron_delta(a, b)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Spin_002d1_002f2-state-kets-and-associated-operators">
<h4 class="subsection"><span>1.2.2 Spin-1/2 state kets and associated operators<a class="copiable-link" href="#Spin_002d1_002f2-state-kets-and-associated-operators"> &para;</a></span></h4>

<p>Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states. It is spanned by two vectors. In the <var class="var">z</var>-basis
these vectors are <code class="code">{zp,zm}</code>, and the basis kets in the
<var class="var">z</var>-basis are <code class="code">{xp,xm}</code> and <code class="code">{yp,ym}</code> respectively.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-zp"><span class="category-def">Function: </span><span><strong class="def-name">zp</strong><a class="copiable-link" href="#index-zp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-zm"><span class="category-def">Function: </span><span><strong class="def-name">zm</strong><a class="copiable-link" href="#index-zm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-xp"><span class="category-def">Function: </span><span><strong class="def-name">xp</strong><a class="copiable-link" href="#index-xp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-xm"><span class="category-def">Function: </span><span><strong class="def-name">xm</strong><a class="copiable-link" href="#index-xm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-yp"><span class="category-def">Function: </span><span><strong class="def-name">yp</strong><a class="copiable-link" href="#index-yp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ym"><span class="category-def">Function: </span><span><strong class="def-name">ym</strong><a class="copiable-link" href="#index-ym"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) zp;
                                     [ 1 ]
(%o1)                                [   ]
                                     [ 0 ]
(%i2) zm;
                                     [ 0 ]
(%o2)                                [   ]
                                     [ 1 ]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) yp;
                                  [    1    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%o1)                             [         ]
                                  [   %i    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%i2) ym;
                                 [     1     ]
                                 [  -------  ]
                                 [  sqrt(2)  ]
(%o2)                            [           ]
                                 [     %i    ]
                                 [ - ------- ]
                                 [   sqrt(2) ]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) braket(xp,zp);
                                       1
(%o1)                               -------
                                    sqrt(2)
</pre></div></div>

<p>Switching bases is done in the following example where a <var class="var">z</var>-basis
ket is constructed and the <var class="var">x</var>-basis ket is computed.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:mket([a,b]);
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) psi_x:'xp*braket(xp,psi)+'xm*braket(xm,psi);
                    b         a              a         b
(%o3)           (------- + -------) xp + (------- - -------) xm
                 sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators">
<h4 class="subsection"><span>1.2.3 Pauli matrices and Sz, Sx, Sy operators<a class="copiable-link" href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmax"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmax</code></strong><a class="copiable-link" href="#index-sigmax"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">x</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmay"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmay</code></strong><a class="copiable-link" href="#index-sigmay"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">y</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmaz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmaz</code></strong><a class="copiable-link" href="#index-sigmaz"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">z</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sx"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sx</code></strong><a class="copiable-link" href="#index-Sx"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sx</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sy"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sy</code></strong><a class="copiable-link" href="#index-Sy"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sy</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sz</code></strong><a class="copiable-link" href="#index-Sz"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sz</var> matrix.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) sigmay;
                                 [ 0   - %i ]
(%o1)                            [          ]
                                 [ %i   0   ]
(%i2) Sy;
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o2)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-commutator"><span class="category-def">Function: </span><span><strong class="def-name">commutator</strong> <var class="def-var-arguments">(<code class="code">X,Y</code>)</var><a class="copiable-link" href="#index-commutator"> &para;</a></span></dt>
<dd><p>Given two operators <code class="code">X</code> and <code class="code">Y</code>, return the
commutator <code class="code">X . Y - Y . X</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) commutator(Sx,Sy);
                           [        2             ]
                           [ %i hbar              ]
                           [ --------      0      ]
                           [    2                 ]
(%o1)                      [                      ]
                           [                    2 ]
                           [             %i hbar  ]
                           [    0      - -------- ]
                           [                2     ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="SX_002c-SY_002c-SZ-operators-for-any-spin">
<h4 class="subsection"><span>1.2.4 SX, SY, SZ operators for any spin<a class="copiable-link" href="#SX_002c-SY_002c-SZ-operators-for-any-spin"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-SX"><span class="category-def">Function: </span><span><strong class="def-name">SX</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SX"> &para;</a></span></dt>
<dd><p><code class="code">SX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sx</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SY"><span class="category-def">Function: </span><span><strong class="def-name">SY</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SY"> &para;</a></span></dt>
<dd><p><code class="code">SY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sy</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SZ"><span class="category-def">Function: </span><span><strong class="def-name">SZ</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SZ"> &para;</a></span></dt>
<dd><p><code class="code">SZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sz</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<p>Example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SY(1/2);
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o1)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
(%i2) SX(1);
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
                         [                           ]
                         [  hbar              hbar   ]
(%o2)                    [ -------     0     ------- ]
                         [ sqrt(2)           sqrt(2) ]
                         [                           ]
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Expectation-value-and-variance">
<h4 class="subsection"><span>1.2.5 Expectation value and variance<a class="copiable-link" href="#Expectation-value-and-variance"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-expect"><span class="category-def">Function: </span><span><strong class="def-name">expect</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-expect"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical expectation value of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">&lt;psi|O|psi&gt;</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(expect(Sy,xp+ym),ratsimp);
(%o1)                               - hbar
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-qm_005fvariance"><span class="category-def">Function: </span><span><strong class="def-name">qm_variance</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-qm_005fvariance"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical variance of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">sqrt(&lt;psi|O<sup class="sup">2</sup>|psi&gt; - &lt;psi|O|psi&gt;<sup class="sup">2</sup>)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(qm_variance(Sy,xp+ym),ratsimp);
                                    %i hbar
(%o1)                               -------
                                       2
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-representation-of-kets-and-bras">
<h4 class="subsection"><span>1.2.6 Angular momentum representation of kets and bras<a class="copiable-link" href="#Angular-momentum-representation-of-kets-and-bras"> &para;</a></span></h4>

<p>To create kets and bras in the <var class="var">|j,m&gt;</var> representation you can use
the following functions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-jmket"><span class="category-def">Function: </span><span><strong class="def-name">jmket</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jmket"> &para;</a></span></dt>
<dd><p><code class="code">jmket</code> creates the ket <var class="var">|j,m&gt;</var> for total spin <var class="var">j</var>
and <var class="var">z</var>-component <var class="var">m</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jmbra"><span class="category-def">Function: </span><span><strong class="def-name">jmbra</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jmbra"> &para;</a></span></dt>
<dd><p><code class="code">jmbra</code> creates the bra <var class="var">&lt;j,m|</var> for total spin <var class="var">j</var>
and <var class="var">z</var>-component <var class="var">m</var>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmbra(3/2,1/2);
                                        3  1
(%o1)                             jmbra(-, -)
                                        2  2
(%i2) jmbra([3/2,1/2]);
                                       [ 3  1 ]
(%o2)                          [jmbra, [ -  - ]]
                                       [ 2  2 ]
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-jmketp"><span class="category-def">Function: </span><span><strong class="def-name">jmketp</strong> <var class="def-var-arguments">(jmket)</var><a class="copiable-link" href="#index-jmketp"> &para;</a></span></dt>
<dd><p><code class="code">jmketp</code> checks to see that the ket has the &rsquo;jmket&rsquo; marker.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmketp(jmket(j,m));
(%o1)                                false
(%i2) jmketp(jmket([j,m]));
(%o2)                                true
</pre></div></div>


<dl class="first-deffn">
<dt class="deffn" id="index-jmbrap"><span class="category-def">Function: </span><span><strong class="def-name">jmbrap</strong> <var class="def-var-arguments">(jmbra)</var><a class="copiable-link" href="#index-jmbrap"> &para;</a></span></dt>
<dd><p><code class="code">jmbrap</code> checks to see that the bra has the &rsquo;jmbra&rsquo; marker.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jmcheck"><span class="category-def">Function: </span><span><strong class="def-name">jmcheck</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jmcheck"> &para;</a></span></dt>
<dd><p><code class="code">jmcheck</code> checks to see that <var class="var">m</var> is one of {-j, &hellip;, +j}.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmcheck(3/2,1/2);
(%o1)                                true
</pre></div></div>


<dl class="first-deffn">
<dt class="deffn" id="index-jmbraket"><span class="category-def">Function: </span><span><strong class="def-name">jmbraket</strong> <var class="def-var-arguments">(<em class="emph">jmbra,jmket</em>)</var><a class="copiable-link" href="#index-jmbraket"> &para;</a></span></dt>
<dd><p><code class="code">jmbraket</code> takes the inner product of the jm-kets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) K:jmket(j1,m1);
(%o1)                            jmket(j1, m1)
(%i2) B:jmbra(j2,m2);
(%o2)                            jmbra(j2, m2)
(%i3) jmbraket(B,K);
(%o3)                kron_delta(j1, j2) kron_delta(m1, m2)
(%i4) B:jmbra(j1,m1);
(%o4)                            jmbra(j1, m1)
(%i5) jmbraket(B,K);
(%o5)                                  1
(%i6) K:jmket([3/2,1/2]);
                                       [ 3  1 ]
(%o6)                          [jmket, [ -  - ]]
                                       [ 2  2 ]
(%i7) B:jmbra([3/2,1/2]);
                                       [ 3  1 ]
(%o7)                          [jmbra, [ -  - ]]
                                       [ 2  2 ]
(%i8) jmbraket(B,K);
(%o8)                                  1
(%i9) jmbraket(jmbra(j1,m1),jmket(j2,m2));
(%o9)                kron_delta(j1, j2) kron_delta(m1, m2)
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-JP"><span class="category-def">Function: </span><span><strong class="def-name">JP</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-JP"> &para;</a></span></dt>
<dd><p><code class="code">JP</code> is the <code class="code">J<sub class="sub">+</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m+1))*hbar*jmket(j,m+1)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-JM"><span class="category-def">Function: </span><span><strong class="def-name">JM</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-JM"> &para;</a></span></dt>
<dd><p><code class="code">JM</code> is the <code class="code">J<sub class="sub">-</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m-1))*hbar*jmket(j,m-1)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Jsqr"><span class="category-def">Function: </span><span><strong class="def-name">Jsqr</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jsqr"> &para;</a></span></dt>
<dd><p><code class="code">Jsqr</code> is the <code class="code">J<sup class="sup">2</sup></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">(j*(j+1)*hbar<sup class="sup">2</sup>*jmket(j,m)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Jz"><span class="category-def">Function: </span><span><strong class="def-name">Jz</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jz"> &para;</a></span></dt>
<dd><p><code class="code">Jz</code> is the <code class="code">J<sub class="sub">z</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">m*hbar*jmket(j,m)</code>.
</p></dd></dl>

<p>These functions are illustrated below.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:jmket([j,m]);
(%o1)                          [jmket, [ j  m ]]
(%i2) JP(k);
(%o2)          hbar jmket(j, m + 1) sqrt(j (j + 1) - m (m + 1))
(%i3) JM(k);
(%o3)          hbar jmket(j, m - 1) sqrt(j (j + 1) - (m - 1) m)
(%i4) Jsqr(k);
                              2
(%o4)                     hbar  j (j + 1) jmket(j, m)
(%i5) Jz(k);
(%o5)                         hbar jmket(j, m) m
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-and-ladder-operators">
<h4 class="subsection"><span>1.2.7 Angular momentum and ladder operators<a class="copiable-link" href="#Angular-momentum-and-ladder-operators"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-SP"><span class="category-def">Function: </span><span><strong class="def-name">SP</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SP"> &para;</a></span></dt>
<dd><p><code class="code">SP</code> is the raising ladder operator <var class="var">S<sub class="sub">+</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SM"><span class="category-def">Function: </span><span><strong class="def-name">SM</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SM"> &para;</a></span></dt>
<dd><p><code class="code">SM</code> is the raising ladder operator <var class="var">S<sub class="sub">-</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<p>Examples of the ladder operators:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SP(1);
                       [ 0  sqrt(2) hbar       0       ]
                       [                               ]
(%o1)                  [ 0       0        sqrt(2) hbar ]
                       [                               ]
                       [ 0       0             0       ]
(%i2) SM(1);
                       [      0             0        0 ]
                       [                               ]
(%o2)                  [ sqrt(2) hbar       0        0 ]
                       [                               ]
                       [      0        sqrt(2) hbar  0 ]
</pre></div></div>

</div>
</div>
<div class="section-level-extent" id="Rotation-operators">
<h3 class="section"><span>1.3 Rotation operators<a class="copiable-link" href="#Rotation-operators"> &para;</a></span></h3>

<dl class="first-deffn">
<dt class="deffn" id="index-RX"><span class="category-def">Function: </span><span><strong class="def-name">RX</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RX"> &para;</a></span></dt>
<dd><p><code class="code">RX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rx</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-RY"><span class="category-def">Function: </span><span><strong class="def-name">RY</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RY"> &para;</a></span></dt>
<dd><p><code class="code">RY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Ry</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-RZ"><span class="category-def">Function: </span><span><strong class="def-name">RZ</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RZ"> &para;</a></span></dt>
<dd><p><code class="code">RZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rz</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) RZ(1/2,t);
Proviso: assuming 64*t # 0 
                             [     %i t         ]
                             [   - ----         ]
                             [      2           ]
                             [ %e          0    ]
(%o1)                        [                  ]
                             [             %i t ]
                             [             ---- ]
                             [              2   ]
                             [    0      %e     ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Time_002devolution-operator">
<h3 class="section"><span>1.4 Time-evolution operator<a class="copiable-link" href="#Time_002devolution-operator"> &para;</a></span></h3>

<dl class="first-deffn">
<dt class="deffn" id="index-UU"><span class="category-def">Function: </span><span><strong class="def-name">UU</strong> <var class="def-var-arguments">(<code class="code">H,t</code>)</var><a class="copiable-link" href="#index-UU"> &para;</a></span></dt>
<dd><p><code class="code">UU(H,t)</code> is the time evolution operator for Hamiltonian <code class="code">H</code>. It
is defined as the matrix exponential <code class="code">matrixexp(-%i*H*t/hbar)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) UU(w*Sy,t);
Proviso: assuming 64*t*w # 0 
                           [     t w         t w  ]
                           [ cos(---)  - sin(---) ]
                           [      2           2   ]
(%o1)                      [                      ]
                           [     t w        t w   ]
                           [ sin(---)   cos(---)  ]
                           [      2          2    ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Tensor-products">
<h3 class="section"><span>1.5 Tensor products<a class="copiable-link" href="#Tensor-products"> &para;</a></span></h3>

<p>Tensor products are represented as lists in the qm package. The ket tensor
product <code class="code">|z+,z+&gt;</code> could be represented as <code class="code">ket([u,d])</code>, for example,
and the bra tensor product <code class="code">&lt;a,b|</code> is represented as <code class="code">bra([a,b])</code> for
states <code class="code">a</code> and <code class="code">b</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-tpket"><span class="category-def">Function: </span><span><strong class="def-name">tpket</strong> <var class="def-var-arguments">([<code class="code">k<sub class="sub">1</sub></code>, <code class="code">k<sub class="sub">2</sub></code>, &hellip;])</var><a class="copiable-link" href="#index-tpket"> &para;</a></span></dt>
<dd><p><code class="code">tpket</code> produces a tensor product of kets <code class="code">k<sub class="sub">i</sub></code>. All
of the elements must pass the <code class="code">ketp</code> predicate test to be
accepted. If a list is not used for the input kets, the tpket will
be an abstract tensor product ket.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tpbra"><span class="category-def">Function: </span><span><strong class="def-name">tpbra</strong> <var class="def-var-arguments">([<code class="code">b<sub class="sub">1</sub></code>, <code class="code">b<sub class="sub">2</sub></code>, &hellip;])</var><a class="copiable-link" href="#index-tpbra"> &para;</a></span></dt>
<dd><p><code class="code">tpbra</code> produces a tensor product of bras <code class="code">b<sub class="sub">i</sub></code>. All
of the elements must pass the <code class="code">brap</code> predicate test to be
accepted. If a list is not used for the input bras, the tpbra will
be an abstract tensor product bra.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tpketp"><span class="category-def">Function: </span><span><strong class="def-name">tpketp</strong> <var class="def-var-arguments">(tpket)</var><a class="copiable-link" href="#index-tpketp"> &para;</a></span></dt>
<dd><p><code class="code">tpketp</code> checks to see that the ket has the &rsquo;tpket&rsquo; marker. Only
the matrix representation will pass this test.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tpbrap"><span class="category-def">Function: </span><span><strong class="def-name">tpbrap</strong> <var class="def-var-arguments">(tpbra)</var><a class="copiable-link" href="#index-tpbrap"> &para;</a></span></dt>
<dd><p><code class="code">tpbrap</code> checks to see that the bra has the &rsquo;tpbra&rsquo; marker. Only
the matrix representation will pass this test.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tpbraket"><span class="category-def">Function: </span><span><strong class="def-name">tpbraket</strong> <var class="def-var-arguments">(<code class="code">B,K</code>)</var><a class="copiable-link" href="#index-tpbraket"> &para;</a></span></dt>
<dd><p><code class="code">tpbraket</code> takes the inner product of the tensor products
<code class="code">B</code> and <code class="code">K</code>. The tensor products must be of the same length
(number of kets must equal the number of bras).
</p></dd></dl>

<p>Examples below show how to create abstract and concrete tensor products
and take the bracket of tensor products.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) kill(a,b,c,d);
(%o1)                                done
(%i2) declare([a,b,c,d],complex);
(%o2)                                done
(%i3) tpbra([mbra([a,b]),mbra([c,d])]);
(%o3)                    [tpbra, [[ a  b ], [ c  d ]]]
(%i4) tpbra([dagger(zp),mbra([c,d])]);
(%o4)                    [tpbra, [[ 1  0 ], [ c  d ]]]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) K:tpket([zp,zm]);
                                     [ 1 ]  [ 0 ]
(%o1)                       [tpket, [[   ], [   ]]]
                                     [ 0 ]  [ 1 ]
(%i2) zpb:dagger(zp);
(%o2)                              [ 1  0 ]
(%i3) zmb:dagger(zm);
(%o3)                              [ 0  1 ]
(%i4) B:tpbra([zpb,zmb]);
(%o4)                    [tpbra, [[ 1  0 ], [ 0  1 ]]]
(%i5) tpbraket(K,B);
(%o5)                                false
(%i6) tpbraket(B,K);
(%o6)                                  1
</pre></div></div>

<p>Examples below show how to create abstract and concrete tensor products
and take the bracket of tensor products.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) K:ket([a1,b1]);
(%o1)                             |[a1, b1]&gt;
(%i2) B:bra([a2,b2]);
(%o2)                             &lt;[a2, b2]|
(%i3) braket(B,K);
(%o3)                kron_delta(a1, a2) kron_delta(b1, b2)
</pre></div><div class="group"><pre class="example-preformatted">(%i1) bra([a1,Id,c1]) . ket([a2,b2,c2]);
(%o1)         |[-, b2, -]&gt; kron_delta(a1, a2) kron_delta(c1, c2)
(%i2) bra([a1,b1,c1]) . ket([Id,b2,c2]);
(%o2)         &lt;[a1, -, -]| kron_delta(b1, b2) kron_delta(c1, c2)
</pre></div></div>

</div>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
