<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Top (Package qm)</title>

<meta name="description" content="Top (Package qm)">
<meta name="keywords" content="Top (Package qm)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#Top" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="../dir_html/index.html" rel="up" title="(dir)">
<link href="#Introduction-to-package-qm" rel="next" title="Introduction to package qm">
<link href="../dir_html/index.html" rel="prev" title="(dir)">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">



<div class="top-level-extent" id="Top">
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<a class="top" id="SEC_Top"></a>

<ul class="mini-toc">
<li><a href="#Package-qm" accesskey="1">Package qm</a></li>
<li><a href="Function-and-Variable-Index.html" accesskey="2">Function and Variable index</a></li>
</ul>
<div class="chapter-level-extent" id="Package-qm">
<h2 class="chapter"><span>1 Package qm<a class="copiable-link" href="#Package-qm"> &para;</a></span></h2>

<ul class="mini-toc">
<li><a href="#Introduction-to-package-qm" accesskey="1">Introduction to package qm</a></li>
<li><a href="#Functions-and-Variables-for-qm" accesskey="2">Functions and Variables for qm</a></li>
<li><a href="#Angular-momentum-representation-of-kets-and-bras" accesskey="3">Angular momentum representation of kets and bras</a></li>
<li><a href="#General-tensor-products" accesskey="4">General tensor products</a></li>
<li><a href="#Quantum-harmonic-oscillator" accesskey="5">Quantum harmonic oscillator</a></li>
<li><a href="#Pre_002ddefined-quantities" accesskey="6">Pre-defined quantities</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-package-qm">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-qm" accesskey="n" rel="next">Functions and Variables for qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-package-qm-1"><span>1.1 Introduction to package qm<a class="copiable-link" href="#Introduction-to-package-qm-1"> &para;</a></span></h3>

<p>The <code class="code">qm</code> package was written by Eric Majzoub, University of
Missouri (email: majzoube-at-umsystem.edu). EM thanks Maxima developers
Robert Dodier and Barton Willis for their contributions that have
improved the package. Please report any errors or unexpected behavior by
submitting an issue on the Github page for this project
(https://github.com/QMeqGR/qm-maxima).
</p>
<p>The purpose of this package is to provide computational tools for
solving quantum mechanics problems in a finite-dimensional Hilbert
space. It was written with students in mind as well as practitioners,
and is appropriate for upper-level undergraduate quantum mechanics at
the level of Townsend&rsquo;s <em class="emph">A Modern Introduction to Quantum
Mechanics</em> and above. Using the package one may compute, for example,
the hyperfine splitting in hydrogen with only a few commands
(See <a class="xref" href="#stationary">stationary</a>). Numerous other examples are given throughout the
manual. Additional examples are provided as wxMaxima worksheets in the
<code class="code">doc/examples</code> folder of the package.
</p>
<br>
<p>The package is loaded with: <code class="code">load(qm);</code>
</p>
<br>
<p>If you use wxMaxima then issue <code class="code">load(&quot;wx.lisp&quot;);</code> <em class="emph">after</em>
loading the <code class="code">qm</code> package. This will allow pretty printing of the
kets and bras similar to what you see in this manual.
</p>
<ul class="mini-toc">
<li><a href="#Basic-capabilities" accesskey="1">Basic capabilities</a></li>
<li><a href="#Kets-and-bras_003a-abstract-and-matrix-representations" accesskey="2">Kets and bras: abstract and matrix representations</a></li>
<li><a href="#Special-ket-types" accesskey="3">Special ket types</a></li>
<li><a href="#Basis-sets" accesskey="4">Basis sets</a></li>
<li><a href="#Types-of-spin-operators_003a-Jxx-and-Sxx-operators" accesskey="5">Types of spin operators: Jxx and Sxx operators</a></li>
</ul>
<div class="subsection-level-extent" id="Basic-capabilities">
<h4 class="subsection"><span>1.1.1 Basic capabilities<a class="copiable-link" href="#Basic-capabilities"> &para;</a></span></h4>

<p>The <code class="code">qm</code> package provides functions and standard definitions to
solve quantum mechanics problems in a finite dimensional Hilbert
space. For example, one can calculate the outcome of Stern-Gerlach
experiments using built-in definitions of the Sx, Sy, and Sz operators
for arbitrary spin, e.g. <code class="code">s={1/2, 1, 3/2, &hellip;}</code>. For spin-1/2
the standard basis kets in the <code class="code">x</code>, <code class="code">y</code>, and <code class="code">z</code>-basis
are defined in the package as <code class="code">{xp,xm}</code>, <code class="code">{yp,ym}</code>, and
<code class="code">{zp,zm}</code>, respectively.
</p>
<p>Brief list of some capabilities:
</p><ul class="itemize mark-bullet">
<li>Create kets and bras in a matrix representation with arbitrary but
finite dimension.
</li><li>Create <em class="emph">general</em> ket vectors with arbitrary but finite dimension.
</li><li>Given an operator and a state ket, perform standard computations of
expectation values, variance, etc.
</li><li>For time-independent Hamiltonians one can construct the time evolution
operator and study, for example, magnetic resonance.  
</li><li>Create kets and bras in the angular momentum <var class="var">|j,m&gt;</var> representation.
</li><li>Create tensor products of states to represent multi-particle systems.
</li><li>Compute Clebsch-Gordan coefficients by stepping up and down the ladder
of states constructed using tensor products of <var class="var">|j,m&gt;</var> kets.
</li><li>Construct Bell states and compute quantities of interest for entangled
systems such as density matrices.
</li><li>Perform partial traces over density matrices to compute reduced
density matrices.
</li></ul>

<p>Let us begin with the trivial example of a spin-1/2 particle. This will
illustrate how kets and bras in a matrix representation are defined
within the <code class="code">qm</code> package. A bra vector in the <code class="code">z</code>-basis may be
written as
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">&lt;psi| = a &lt;z+| + b &lt;z-|</code>.
</p>
<p>The matrix representation of the bra <code class="code">&lt;psi|</code> will be represented in
Maxima by the row vector <code class="code">[a b]</code>, where the basis vectors are
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">&lt;z+| = [1 0]</code>
</p>
<p>and
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">&lt;z-| = [0 1]</code>.
</p>
<p>This bra vector can be created in several ways. First, with the
<code class="code">mbra</code> command
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">mbra([a,b])</code>
</p>
<p>or by taking the quantum mechanical dagger of the corresponding ket. In
a Maxima session this looks like the following. The basis kets
<code class="code">{zp,zm}</code> are transformed into bras using the <code class="code">dagger</code>
function.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) zp;
                                     [ 1 ]
(%o1)                                [   ]
                                     [ 0 ]
(%i2) zm;
                                     [ 0 ]
(%o2)                                [   ]
                                     [ 1 ]
</pre></div></div>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) psi_bra:a*dagger(zp)+b*dagger(zm);
(%o1)                              [ a  b ]
(%i2) dagger(mket([a,b]));
(%o2)                              [ a  b ]
(%i3) mbra([a,b]);
(%o3)                              [ a  b ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Kets-and-bras_003a-abstract-and-matrix-representations">
<h4 class="subsection"><span>1.1.2 Kets and bras: abstract and matrix representations<a class="copiable-link" href="#Kets-and-bras_003a-abstract-and-matrix-representations"> &para;</a></span></h4>

<p>There are two types of kets and bras available in the <code class="code">qm</code> package,
the first type is given by a <em class="emph">matrix representation</em>, as returned
by the functions <code class="code">mbra</code> and <code class="code">mket</code>. <code class="code">mket</code>s are column
vectors and <code class="code">mbra</code>s are row vectors, and their components are
entered as Maxima <em class="emph">lists</em> in the <code class="code">mbra</code> and <code class="code">mket</code>
functions. The second type of bra or ket is <em class="emph">abstract</em>; there is no
matrix representation. Abstract bras and kets are entered using the
<code class="code">bra</code> and <code class="code">ket</code> functions, while also using Maxima lists for
the elements. These general kets are displayed in Dirac
notation. Abstract bras and kets are used for both the <code class="code">(j,m)</code>
representation of states and also for tensor products. For example, a
tensor product of two ket vectors <code class="code">|a&gt;</code> and <code class="code">|b&gt;</code> is input as
<code class="code">ket([a,b])</code> and displayed as
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">|a,b&gt;</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(general ket)
</p>
<p>Note that abstract kets and bras are <em class="emph">assumed to be
orthonormal</em>. These general bras and kets may be used to build
arbitrarily large tensor product states.
</p>
<p>The following examples illustrate some of the basic capabilities of the
<code class="code">qm</code> package. Here both abstract, and concrete (matrix
representation) kets are shown. The last example shows how to construct
an entangled Bell pair.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ket([a,b])+ket([c,d]);
(%o1)                           |c, d&gt; + |a, b&gt;
(%i2) mket([a,b]);
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) mbra([a,b]);
(%o3)                              [ a  b ]
(%i4) bell:(1/sqrt(2))*(ket([u,d])-ket([d,u]));
                                |u, d&gt; - |d, u&gt;
(%o4)                           ---------------
                                    sqrt(2)
(%i5) dagger(bell);
                                &lt;u, d| - &lt;d, u|
(%o5)                           ---------------
                                    sqrt(2)
</pre></div></div>

<p>Note that <code class="code">ket([a,b])</code> is treated as tensor product of states
<code class="code">a</code> and <code class="code">b</code> as shown below.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) braket(bra([a1,b1]),ket([a2,b2]));
(%o1)                kron_delta(a1, a2) kron_delta(b1, b2)
</pre></div></div>

<p>Constants that multiply kets and bras must be declared complex by
the user in order for the dagger function to properly conjugate
such constants. The example below illustrates this behavior.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:a*ket([1])+b*ket([2]);
(%o2)                            |2&gt; b + |1&gt; a
(%i3) psidag:dagger(psi);
(%o3)                 &lt;2| conjugate(b) + &lt;1| conjugate(a)
(%i4) psidag . psi;
(%o4)                   b conjugate(b) + a conjugate(a)
</pre></div></div>

<p>The following shows how to declare a ket with both real and
complex components in the matrix representation.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([c1,c2],complex,r,real);
(%o1)                                done
(%i2) k:mket([c1,c2,r]);
                                    [ c1 ]
                                    [    ]
(%o2)                               [ c2 ]
                                    [    ]
                                    [ r  ]
(%i3) b:dagger(k);
(%o3)                 [ conjugate(c1)  conjugate(c2)  r ]
(%i4) b . k;
                    2
(%o4)              r  + c2 conjugate(c2) + c1 conjugate(c1)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Special-ket-types">
<h4 class="subsection"><span>1.1.3 Special ket types<a class="copiable-link" href="#Special-ket-types"> &para;</a></span></h4>

<p>Some kets are difficult to work with using either the matrix
representation or the general ket representation. These include tensor
products of (j,m) kets used in the addition of angular momentum
computations. For this reason there are a set of <code class="code">tpket</code>s and
associated <code class="code">tpXX</code> functions defined in section <code class="code">(j,m)-kets and
bras</code>.
</p>
</div>
<div class="subsection-level-extent" id="Basis-sets">
<h4 class="subsection"><span>1.1.4 Basis sets<a class="copiable-link" href="#Basis-sets"> &para;</a></span></h4>

<p>As described above there are three basis ket types: mkets that have a
matrix representation, abstract kets that are displayed in Dirac
notation, and tensor product kets. Each of the three kets types can be
used to construct a basis set. Valid basis sets are simply Maxima lists
whose elements are one of the three ket types.
</p>
<br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[b<sub class="sub">1</sub>, b<sub class="sub">2</sub>, b<sub class="sub">3</sub>, &hellip; ]
</p>
<p>Basis sets may be generated automatically using the <code class="code">basis_set</code>
shown in See <a class="xref" href="#basis_005fset">basis_set</a>.
</p>
</div>
<div class="subsection-level-extent" id="Types-of-spin-operators_003a-Jxx-and-Sxx-operators">
<h4 class="subsection"><span>1.1.5 Types of spin operators: Jxx and Sxx operators<a class="copiable-link" href="#Types-of-spin-operators_003a-Jxx-and-Sxx-operators"> &para;</a></span></h4>

<p>When working with kets and bras in the matrix representation, use the
spin operators <code class="code">Sxx</code>. When working with abstract kets and bras in
the (j,m) representation use the operators <code class="code">Jxx</code>. The family of
<code class="code">Sxx</code> operators are represented as matrices in Maxima, while the
family of <code class="code">Jxx</code> operators are rule based or function based.
</p>

<hr>
</div>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-qm">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-package-qm" accesskey="p" rel="prev">Introduction to package qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-qm-1"><span>1.2 Functions and Variables for qm<a class="copiable-link" href="#Functions-and-Variables-for-qm-1"> &para;</a></span></h3>

<a class="anchor" id="hbar"></a><dl class="first-defvr">
<dt class="defvr" id="index-hbar"><span class="category-def">Variable: </span><span><strong class="def-name">hbar</strong><a class="copiable-link" href="#index-hbar"> &para;</a></span></dt>
<dd><p>Planck&rsquo;s constant divided by <code class="code">2*%pi</code>. <code class="code">hbar</code> is not given a
floating point value, but is declared to be a real number greater than
zero. If the system variable <code class="code">display2d_unicode</code> is <code class="code">true</code> then
<code class="code">hbar</code> will be displayed as its Unicode character.
</p></dd></dl>

<a class="anchor" id="ket"></a><dl class="first-deffn">
<dt class="deffn" id="index-ket"><span class="category-def">Function: </span><span><strong class="def-name">ket</strong> <var class="def-var-arguments">([<code class="code">k<sub class="sub">1</sub></code>,<code class="code">k<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-ket"> &para;</a></span></dt>
<dd><p><code class="code">ket</code> creates a general state ket, or tensor product, with symbols
<code class="code">k<sub class="sub">i</sub></code> representing the states. The state kets <code class="code">k<sub class="sub">i</sub></code>
are assumed to be orthonormal.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([u,d]);
(%o1)                               |u, d&gt;
(%i2) b:bra([u,d]);
(%o2)                               &lt;u, d|
(%i3) b . k;
(%o3)                                  1
</pre></div></div>

<a class="anchor" id="ketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-ketp"><span class="category-def">Function: </span><span><strong class="def-name">ketp</strong> <var class="def-var-arguments">(abstract ket)</var><a class="copiable-link" href="#index-ketp"> &para;</a></span></dt>
<dd><p><code class="code">ketp</code> is a predicate function for abstract kets. It returns
<code class="code">true</code> for abstract <code class="code">ket</code>s and <code class="code">false</code> for anything else.
</p></dd></dl>

<a class="anchor" id="bra"></a><dl class="first-deffn">
<dt class="deffn" id="index-bra"><span class="category-def">Function: </span><span><strong class="def-name">bra</strong> <var class="def-var-arguments">([<code class="code">b<sub class="sub">1</sub></code>,<code class="code">b<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-bra"> &para;</a></span></dt>
<dd><p><code class="code">bra</code> creates a general state bra, or tensor product, with symbols
<code class="code">b<sub class="sub">i</sub></code> representing the states. The state bras <code class="code">b<sub class="sub">i</sub></code>
are assumed to be orthonormal.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([u,d]);
(%o1)                               |u, d&gt;
(%i2) b:bra([u,d]);
(%o2)                               &lt;u, d|
(%i3) b . k;
(%o3)                                  1
</pre></div></div>

<a class="anchor" id="brap"></a><dl class="first-deffn">
<dt class="deffn" id="index-brap"><span class="category-def">Function: </span><span><strong class="def-name">brap</strong> <var class="def-var-arguments">(abstract bra)</var><a class="copiable-link" href="#index-brap"> &para;</a></span></dt>
<dd><p><code class="code">brap</code> is a predicate function for abstract bras. It returns
<code class="code">true</code> for abstract <code class="code">bra</code>s and <code class="code">false</code> for anything else.
</p></dd></dl>

<a class="anchor" id="mket"></a><dl class="first-deffn">
<dt class="deffn" id="index-mket"><span class="category-def">Function: </span><span><strong class="def-name">mket</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-mket"> &para;</a></span></dt>
<dd><p><code class="code">mket</code> creates a <em class="emph">column</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex. For a
matrix representation the elements must be entered as a list in
<code class="code">[&hellip;]</code> square brackets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([c1,c2],complex);
(%o1)                                done
(%i2) mket([c1,c2]);
                                    [ c1 ]
(%o2)                               [    ]
                                    [ c2 ]
(%i3) facts();
(%o3) [kind(tpscmult, multiadditive), kind(hbar, real), kind(ħ, real), 
                                hbar &gt; 0, kind(c1, complex), kind(c2, complex)]
</pre></div></div>

<a class="anchor" id="mketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-mketp"><span class="category-def">Function: </span><span><strong class="def-name">mketp</strong> <var class="def-var-arguments">(<em class="emph">ket</em>)</var><a class="copiable-link" href="#index-mketp"> &para;</a></span></dt>
<dd><p><code class="code">mketp</code> is a predicate function that checks if its input is an mket,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">mketp</code> only returns <code class="code">true</code> for the matrix representation of a ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([a,b]);
(%o1)                               |a, b&gt;
(%i2) mketp(k);
(%o2)                                false
(%i3) k:mket([a,b]);
                                     [ a ]
(%o3)                                [   ]
                                     [ b ]
(%i4) mketp(k);
(%o4)                                true
</pre></div></div>

<a class="anchor" id="mbra"></a><dl class="first-deffn">
<dt class="deffn" id="index-mbra"><span class="category-def">Function: </span><span><strong class="def-name">mbra</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-mbra"> &para;</a></span></dt>
<dd><p><code class="code">mbra</code> creates a <em class="emph">row</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex.
For a matrix representation the elements must be entered as a list
in <code class="code">[&hellip;]</code> square brackets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) kill(c1,c2);
(%o1)                                done
(%i2) mbra([c1,c2]);
(%o2)                             [ c1  c2 ]
(%i3) facts();
(%o3) [kind(tpscmult, multiadditive), kind(hbar, real), kind(ħ, real), 
                                                                      hbar &gt; 0]
</pre></div></div>

<a class="anchor" id="mbrap"></a><dl class="first-deffn">
<dt class="deffn" id="index-mbrap"><span class="category-def">Function: </span><span><strong class="def-name">mbrap</strong> <var class="def-var-arguments">(<em class="emph">bra</em>)</var><a class="copiable-link" href="#index-mbrap"> &para;</a></span></dt>
<dd><p><code class="code">mbrap</code> is a predicate function that checks if its input is an mbra,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">mbrap</code> only returns <code class="code">true</code> for the matrix representation of a bra.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) b:mbra([a,b]);
(%o1)                              [ a  b ]
(%i2) mbrap(b);
(%o2)                                true
</pre></div></div>

<p>Two additional functions are provided to create kets and bras in the
matrix representation. These functions conveniently attempt to
automatically <code class="code">declare</code> constants as complex. For example, if a
list entry is <code class="code">a*sin(x)+b*cos(x)</code> then only <code class="code">a</code> and <code class="code">b</code>
will be <code class="code">declare</code>-d complex and not <code class="code">x</code>.
</p>
<a class="anchor" id="autoket"></a><dl class="first-deffn">
<dt class="deffn" id="index-autoket"><span class="category-def">Function: </span><span><strong class="def-name">autoket</strong> <var class="def-var-arguments">([<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>])</var><a class="copiable-link" href="#index-autoket"> &para;</a></span></dt>
<dd><p><code class="code">autoket</code> takes a list [<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>] and
returns a ket with the coefficients <code class="code">a<sub class="sub">i</sub></code> <code class="code">declare</code>-d
complex. Simple expressions such as <code class="code">a*sin(x)+b*cos(x)</code> are allowed
and will <code class="code">declare</code> only the coefficients as complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) autoket([a,b]);
                                     [ a ]
(%o1)                                [   ]
                                     [ b ]
(%i2) facts();
(%o2) [kind(tpscmult, multiadditive), kind(hbar, real), kind(ħ, real), 
                                  hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) autoket([a*sin(x),b*sin(x)]);
                                 [ a sin(x) ]
(%o1)                            [          ]
                                 [ b sin(x) ]
(%i2) facts();
(%o2) [kind(tpscmult, multiadditive), kind(hbar, real), kind(ħ, real), 
                                  hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div></div>

<a class="anchor" id="autobra"></a><dl class="first-deffn">
<dt class="deffn" id="index-autobra"><span class="category-def">Function: </span><span><strong class="def-name">autobra</strong> <var class="def-var-arguments">([<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>])</var><a class="copiable-link" href="#index-autobra"> &para;</a></span></dt>
<dd><p><code class="code">autobra</code> takes a list [<code class="code">a<sub class="sub">1</sub>,a<sub class="sub">2</sub>,&hellip;</code>] and
returns a bra with the coefficients <code class="code">a<sub class="sub">i</sub></code> <code class="code">declare</code>-d
complex. Simple expressions such as <code class="code">a*sin(x)+b*cos(x)</code> are allowed
and will <code class="code">declare</code> only the coefficients as complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) autobra([a,b]);
(%o1)                              [ a  b ]
(%i2) facts();
(%o2) [kind(tpscmult, multiadditive), kind(hbar, real), kind(ħ, real), 
                                  hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) autobra([a*sin(x),b]);
(%o1)                           [ a sin(x)  b ]
(%i2) facts();
(%o2) [kind(tpscmult, multiadditive), kind(hbar, real), kind(ħ, real), 
                                  hbar &gt; 0, kind(a, complex), kind(b, complex)]
</pre></div></div>

<a class="anchor" id="dagger"></a><dl class="first-deffn">
<dt class="deffn" id="index-dagger"><span class="category-def">Function: </span><span><strong class="def-name">dagger</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-dagger"> &para;</a></span></dt>
<dd><p><code class="code">dagger</code> is the quantum mechanical <em class="emph">dagger</em> function and returns
the <code class="code">conjugate</code> <code class="code">transpose</code> of its input. Arbitrary constants
must be <code class="code">declare</code>-d complex for dagger to produce the conjugate.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dagger(mbra([%i,2]));
                                   [ - %i ]
(%o1)                              [      ]
                                   [  2   ]
</pre></div></div>

<a class="anchor" id="braket"></a><dl class="first-deffn">
<dt class="deffn" id="index-braket"><span class="category-def">Function: </span><span><strong class="def-name">braket</strong> <var class="def-var-arguments">(<code class="code">psi,phi</code>)</var><a class="copiable-link" href="#index-braket"> &para;</a></span></dt>
<dd><p>Given a bra <code class="code">psi</code> and ket <code class="code">phi</code>, <code class="code">braket</code> returns the
quantum mechanical bracket <code class="code">&lt;psi|phi&gt;</code>. Note, <code class="code">braket(b,k)</code> is
equivalent to <code class="code">b . k</code> where <code class="code">.</code> is the Maxima non-commutative
<code class="code">dot</code> operator.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) braket(mbra([a,b,c]),mket([a,b,c]));
                                  2    2    2
(%o2)                            c  + b  + a
(%i3) braket(dagger(mket([a,b,c])),mket([a,b,c]));
(%o3)          c conjugate(c) + b conjugate(b) + a conjugate(a)
(%i4) braket(bra([a1,b1,c1]),ket([a2,b2,c2]));
(%o4)      kron_delta(a1, a2) kron_delta(b1, b2) kron_delta(c1, c2)
</pre></div></div>

<a class="anchor" id="norm"></a><dl class="first-deffn">
<dt class="deffn" id="index-norm"><span class="category-def">Function: </span><span><strong class="def-name">norm</strong> <var class="def-var-arguments">(<code class="code">psi</code>)</var><a class="copiable-link" href="#index-norm"> &para;</a></span></dt>
<dd><p>Given a <code class="code">ket</code> or <code class="code">bra</code> <code class="code">psi</code>, <code class="code">norm</code> returns the
square root of the quantum mechanical bracket <code class="code">&lt;psi|psi&gt;</code>.
The vector <code class="code">psi</code> must always be a <code class="code">ket</code>, otherwise the
function will return <code class="code">false</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) norm(mket([a,b,c]));
(%o2)       sqrt(c conjugate(c) + b conjugate(b) + a conjugate(a))
</pre></div></div>

<a class="anchor" id="magsqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-magsqr"><span class="category-def">Function: </span><span><strong class="def-name">magsqr</strong> <var class="def-var-arguments">(<code class="code">c</code>)</var><a class="copiable-link" href="#index-magsqr"> &para;</a></span></dt>
<dd><p><code class="code">magsqr</code> returns <code class="code">conjugate(c)*c</code>, the magnitude
squared of a complex number.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c,d],complex);
(%o1)                                done
(%i2) braket(mbra([a,b]),mket([c,d]));
(%o2)                              b d + a c
(%i3) P:magsqr(%);
(%o3) (b d + a c) (conjugate(b) conjugate(d) + conjugate(a) conjugate(c))
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Spin_002d1_002f2-state-kets-and-associated-operators" accesskey="1">Spin-1/2 state kets and associated operators</a></li>
<li><a href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators" accesskey="2">Pauli matrices and Sz, Sx, Sy operators</a></li>
<li><a href="#SX_002c-SY_002c-SZ-operators-for-any-spin" accesskey="3">SX, SY, SZ operators for any spin</a></li>
<li><a href="#Basis-set-transformations" accesskey="4">Basis set transformations</a></li>
<li><a href="#Expectation-value-and-variance" accesskey="5">Expectation value and variance</a></li>
<li><a href="#Angular-momentum-and-ladder-operators-in-the-matrix-representation" accesskey="6">Angular momentum and ladder operators in the matrix representation</a></li>
<li><a href="#Rotation-operators" accesskey="7">Rotation operators</a></li>
<li><a href="#Time_002devolution-operator" accesskey="8">Time-evolution operator</a></li>
</ul>
<div class="subsection-level-extent" id="Spin_002d1_002f2-state-kets-and-associated-operators">
<h4 class="subsection"><span>1.2.1 Spin-1/2 state kets and associated operators<a class="copiable-link" href="#Spin_002d1_002f2-state-kets-and-associated-operators"> &para;</a></span></h4>

<p>Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states. It is spanned by two vectors. In the <var class="var">z</var>-basis
these vectors are <code class="code">{zp,zm}</code>, and the basis kets in the
<var class="var">z</var>-basis are <code class="code">{xp,xm}</code> and <code class="code">{yp,ym}</code> respectively.
</p>
<a class="anchor" id="zp"></a><dl class="first-deffn">
<dt class="deffn" id="index-zp"><span class="category-def">Function: </span><span><strong class="def-name">zp</strong><a class="copiable-link" href="#index-zp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="zm"></a><dl class="first-deffn">
<dt class="deffn" id="index-zm"><span class="category-def">Function: </span><span><strong class="def-name">zm</strong><a class="copiable-link" href="#index-zm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="xp"></a><dl class="first-deffn">
<dt class="deffn" id="index-xp"><span class="category-def">Function: </span><span><strong class="def-name">xp</strong><a class="copiable-link" href="#index-xp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="xm"></a><dl class="first-deffn">
<dt class="deffn" id="index-xm"><span class="category-def">Function: </span><span><strong class="def-name">xm</strong><a class="copiable-link" href="#index-xm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="yp"></a><dl class="first-deffn">
<dt class="deffn" id="index-yp"><span class="category-def">Function: </span><span><strong class="def-name">yp</strong><a class="copiable-link" href="#index-yp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<a class="anchor" id="ym"></a><dl class="first-deffn">
<dt class="deffn" id="index-ym"><span class="category-def">Function: </span><span><strong class="def-name">ym</strong><a class="copiable-link" href="#index-ym"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>


<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) yp;
                                  [    1    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%o1)                             [         ]
                                  [   %i    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%i2) ym;
                                 [     1     ]
                                 [  -------  ]
                                 [  sqrt(2)  ]
(%o2)                            [           ]
                                 [     %i    ]
                                 [ - ------- ]
                                 [   sqrt(2) ]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) braket(dagger(xp),zp);
                                       1
(%o1)                               -------
                                    sqrt(2)
</pre></div></div>

<p>Switching bases is done in the following example where a <var class="var">z</var>-basis
ket is constructed and the <var class="var">x</var>-basis ket is computed.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:mket([a,b]);
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) psi_x:'xp*braket(dagger(xp),psi)+'xm*braket(dagger(xm),psi);
                    b         a              a         b
(%o3)           (------- + -------) xp + (------- - -------) xm
                 sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators">
<h4 class="subsection"><span>1.2.2 Pauli matrices and Sz, Sx, Sy operators<a class="copiable-link" href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators"> &para;</a></span></h4>

<a class="anchor" id="sigmax"></a><dl class="first-deffn">
<dt class="deffn" id="index-sigmax"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmax</code></strong><a class="copiable-link" href="#index-sigmax"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">x</var> matrix.
</p></dd></dl>

<a class="anchor" id="sigmay"></a><dl class="first-deffn">
<dt class="deffn" id="index-sigmay"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmay</code></strong><a class="copiable-link" href="#index-sigmay"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">y</var> matrix.
</p></dd></dl>

<a class="anchor" id="sigmaz"></a><dl class="first-deffn">
<dt class="deffn" id="index-sigmaz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmaz</code></strong><a class="copiable-link" href="#index-sigmaz"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">z</var> matrix.
</p></dd></dl>

<a class="anchor" id="Sx"></a><dl class="first-deffn">
<dt class="deffn" id="index-Sx"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sx</code></strong><a class="copiable-link" href="#index-Sx"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sx</var> matrix.
</p></dd></dl>

<a class="anchor" id="Sy"></a><dl class="first-deffn">
<dt class="deffn" id="index-Sy"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sy</code></strong><a class="copiable-link" href="#index-Sy"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sy</var> matrix.
</p></dd></dl>

<a class="anchor" id="Sz"></a><dl class="first-deffn">
<dt class="deffn" id="index-Sz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sz</code></strong><a class="copiable-link" href="#index-Sz"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sz</var> matrix.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) sigmay;
                                 [ 0   - %i ]
(%o1)                            [          ]
                                 [ %i   0   ]
(%i2) Sy;
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o2)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
</pre></div></div>

<a class="anchor" id="commutator"></a><dl class="first-deffn">
<dt class="deffn" id="index-commutator"><span class="category-def">Function: </span><span><strong class="def-name">commutator</strong> <var class="def-var-arguments">(<code class="code">X,Y</code>)</var><a class="copiable-link" href="#index-commutator"> &para;</a></span></dt>
<dd><p>Given two operators <code class="code">X</code> and <code class="code">Y</code>, return the
commutator <code class="code">X . Y - Y . X</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) commutator(Sx,Sy);
                           [        2             ]
                           [ %i hbar              ]
                           [ --------      0      ]
                           [    2                 ]
(%o1)                      [                      ]
                           [                    2 ]
                           [             %i hbar  ]
                           [    0      - -------- ]
                           [                2     ]
</pre></div></div>

<a class="anchor" id="anticommutator"></a><dl class="first-deffn">
<dt class="deffn" id="index-anticommutator"><span class="category-def">Function: </span><span><strong class="def-name">anticommutator</strong> <var class="def-var-arguments">(<code class="code">X,Y</code>)</var><a class="copiable-link" href="#index-anticommutator"> &para;</a></span></dt>
<dd><p>Given two operators <code class="code">X</code> and <code class="code">Y</code>, return the
commutator <code class="code">X . Y + Y . X</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) (1/2)*anticommutator(sigmax,sigmax);
                                   [ 1  0 ]
(%o1)                              [      ]
                                   [ 0  1 ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="SX_002c-SY_002c-SZ-operators-for-any-spin">
<h4 class="subsection"><span>1.2.3 SX, SY, SZ operators for any spin<a class="copiable-link" href="#SX_002c-SY_002c-SZ-operators-for-any-spin"> &para;</a></span></h4>

<a class="anchor" id="SX"></a><dl class="first-deffn">
<dt class="deffn" id="index-SX"><span class="category-def">Function: </span><span><strong class="def-name">SX</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SX"> &para;</a></span></dt>
<dd><p><code class="code">SX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sx</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<a class="anchor" id="SY"></a><dl class="first-deffn">
<dt class="deffn" id="index-SY"><span class="category-def">Function: </span><span><strong class="def-name">SY</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SY"> &para;</a></span></dt>
<dd><p><code class="code">SY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sy</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<a class="anchor" id="SZ"></a><dl class="first-deffn">
<dt class="deffn" id="index-SZ"><span class="category-def">Function: </span><span><strong class="def-name">SZ</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SZ"> &para;</a></span></dt>
<dd><p><code class="code">SZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sz</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<p>Example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SY(1/2);
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o1)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
(%i2) SX(1);
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
                         [                           ]
                         [  hbar              hbar   ]
(%o2)                    [ -------     0     ------- ]
                         [ sqrt(2)           sqrt(2) ]
                         [                           ]
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Basis-set-transformations">
<h4 class="subsection"><span>1.2.4 Basis set transformations<a class="copiable-link" href="#Basis-set-transformations"> &para;</a></span></h4>

<p>Given a matrix representation of an operator in terms of <code class="code">mket</code>s
one may transform from one <code class="code">mket</code> basis to another.
</p>
<a class="anchor" id="basis_005fset_005fp"></a><dl class="first-deffn">
<dt class="deffn" id="index-basis_005fset_005fp"><span class="category-def">Function: </span><span><strong class="def-name">basis_set_p</strong> <var class="def-var-arguments">(<code class="code">B</code>)</var><a class="copiable-link" href="#index-basis_005fset_005fp"> &para;</a></span></dt>
<dd><p>The predicate function <code class="code">basis_set_p</code> takes as an argument a basis
set <code class="code">[b<sub class="sub">1</sub>,b<sub class="sub">2</sub>,&hellip;]</code> enclosed in square brackets,
where each <code class="code">b<sub class="sub">i</sub></code> is <code class="code">true</code> for the predicate function
<code class="code">mketp</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) basis_set_p([zp,zm]);
(%o1)                                true
</pre></div></div>

<a class="anchor" id="mtrans"></a><dl class="first-deffn">
<dt class="deffn" id="index-mtrans"><span class="category-def">Function: </span><span><strong class="def-name">mtrans</strong> <var class="def-var-arguments">(<code class="code">B<sub class="sub">1</sub>,B<sub class="sub">2</sub></code>)</var><a class="copiable-link" href="#index-mtrans"> &para;</a></span></dt>
<dd><p>The function <code class="code">mtrans</code> returns the matrix of inner products of the
two bases <code class="code">B<sub class="sub">1</sub></code> and <code class="code">B<sub class="sub">2</sub></code>. The bases must be of the
same dimension.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) mtrans([zp,zm],[yp,ym]);
                            [    1         1     ]
                            [ -------   -------  ]
                            [ sqrt(2)   sqrt(2)  ]
(%o1)                       [                    ]
                            [   %i         %i    ]
                            [ -------  - ------- ]
                            [ sqrt(2)    sqrt(2) ]
</pre></div></div>


<a class="anchor" id="op_005ftrans"></a><dl class="first-deffn">
<dt class="deffn" id="index-op_005ftrans"><span class="category-def">Function: </span><span><strong class="def-name">op_trans</strong> <var class="def-var-arguments">(<code class="code">A,B<sub class="sub">1</sub>,B<sub class="sub">2</sub></code>)</var><a class="copiable-link" href="#index-op_005ftrans"> &para;</a></span></dt>
<dd><p>The function <code class="code">op_trans</code> returns the matrix representation of
operator <code class="code">A</code> in basis <code class="code">B<sub class="sub">2</sub></code>. The operator <code class="code">A</code> must
be given in the basis <code class="code">B<sub class="sub">1</sub></code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) op_trans(Sy,[zp,zm],[yp,ym]);
                               [ hbar         ]
                               [ ----    0    ]
                               [  2           ]
(%o1)                          [              ]
                               [         hbar ]
                               [  0    - ---- ]
                               [          2   ]
</pre></div></div>


</div>
<div class="subsection-level-extent" id="Expectation-value-and-variance">
<h4 class="subsection"><span>1.2.5 Expectation value and variance<a class="copiable-link" href="#Expectation-value-and-variance"> &para;</a></span></h4>

<a class="anchor" id="expect"></a><dl class="first-deffn">
<dt class="deffn" id="index-expect"><span class="category-def">Function: </span><span><strong class="def-name">expect</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-expect"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical expectation value of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">&lt;psi|O|psi&gt;</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(expect(Sy,xp+ym),ratsimp);
(%o1)                               - hbar
</pre></div></div>

<a class="anchor" id="qm_005fvariance"></a><dl class="first-deffn">
<dt class="deffn" id="index-qm_005fvariance"><span class="category-def">Function: </span><span><strong class="def-name">qm_variance</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-qm_005fvariance"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical variance of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">sqrt(&lt;psi|O<sup class="sup">2</sup>|psi&gt; - &lt;psi|O|psi&gt;<sup class="sup">2</sup>)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(qm_variance(Sy,xp+ym),ratsimp);
                                    %i hbar
(%o1)                               -------
                                       2
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-and-ladder-operators-in-the-matrix-representation">
<h4 class="subsection"><span>1.2.6 Angular momentum and ladder operators in the matrix representation<a class="copiable-link" href="#Angular-momentum-and-ladder-operators-in-the-matrix-representation"> &para;</a></span></h4>

<a class="anchor" id="SP"></a><dl class="first-deffn">
<dt class="deffn" id="index-SP"><span class="category-def">Function: </span><span><strong class="def-name">SP</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SP"> &para;</a></span></dt>
<dd><p><code class="code">SP</code> is the raising ladder operator <var class="var">S<sub class="sub">+</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<a class="anchor" id="SM"></a><dl class="first-deffn">
<dt class="deffn" id="index-SM"><span class="category-def">Function: </span><span><strong class="def-name">SM</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SM"> &para;</a></span></dt>
<dd><p><code class="code">SM</code> is the raising ladder operator <var class="var">S<sub class="sub">-</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<p>Examples of the ladder operators:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SP(1);
                       [ 0  sqrt(2) hbar       0       ]
                       [                               ]
(%o1)                  [ 0       0        sqrt(2) hbar ]
                       [                               ]
                       [ 0       0             0       ]
(%i2) SM(1);
                       [      0             0        0 ]
                       [                               ]
(%o2)                  [ sqrt(2) hbar       0        0 ]
                       [                               ]
                       [      0        sqrt(2) hbar  0 ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Rotation-operators">
<h4 class="subsection"><span>1.2.7 Rotation operators<a class="copiable-link" href="#Rotation-operators"> &para;</a></span></h4>

<a class="anchor" id="RX"></a><dl class="first-deffn">
<dt class="deffn" id="index-RX"><span class="category-def">Function: </span><span><strong class="def-name">RX</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RX"> &para;</a></span></dt>
<dd><p><code class="code">RX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rx</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<a class="anchor" id="RY"></a><dl class="first-deffn">
<dt class="deffn" id="index-RY"><span class="category-def">Function: </span><span><strong class="def-name">RY</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RY"> &para;</a></span></dt>
<dd><p><code class="code">RY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Ry</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<a class="anchor" id="RZ"></a><dl class="first-deffn">
<dt class="deffn" id="index-RZ"><span class="category-def">Function: </span><span><strong class="def-name">RZ</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RZ"> &para;</a></span></dt>
<dd><p><code class="code">RZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rz</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) RY(1,t);
                     [ cos(t) + 1    sin(t)   1 - cos(t) ]
                     [ ----------  - -------  ---------- ]
                     [     2         sqrt(2)      2      ]
                     [                                   ]
                     [  sin(t)                  sin(t)   ]
(%o1)                [  -------     cos(t)    - -------  ]
                     [  sqrt(2)                 sqrt(2)  ]
                     [                                   ]
                     [ 1 - cos(t)   sin(t)    cos(t) + 1 ]
                     [ ----------   -------   ---------- ]
                     [     2        sqrt(2)       2      ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Time_002devolution-operator">
<h4 class="subsection"><span>1.2.8 Time-evolution operator<a class="copiable-link" href="#Time_002devolution-operator"> &para;</a></span></h4>

<a class="anchor" id="U"></a><dl class="first-deffn">
<dt class="deffn" id="index-U"><span class="category-def">Function: </span><span><strong class="def-name">U</strong> <var class="def-var-arguments">(<code class="code">H,t</code>)</var><a class="copiable-link" href="#index-U"> &para;</a></span></dt>
<dd><p><code class="code">U(H,t)</code> is the time evolution operator for Hamiltonian <code class="code">H</code>. It
is defined as the matrix exponential <code class="code">matrixexp(-%i*H*t/hbar)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) assume(w &gt; 0);
(%o1)                               [w &gt; 0]
(%i2) U(w*Sy,t);
                           [     t w         t w  ]
                           [ cos(---)  - sin(---) ]
                           [      2           2   ]
(%o2)                      [                      ]
                           [     t w        t w   ]
                           [ sin(---)   cos(---)  ]
                           [      2          2    ]
</pre></div></div>

</div>
</div>
<div class="section-level-extent" id="Angular-momentum-representation-of-kets-and-bras">
<h3 class="section"><span>1.3 Angular momentum representation of kets and bras<a class="copiable-link" href="#Angular-momentum-representation-of-kets-and-bras"> &para;</a></span></h3>

<ul class="mini-toc">
<li><a href="#Matrix-representation-of-_0028j_002cm_0029_002dkets-and-bras" accesskey="1">Matrix representation of (j,m)-kets and bras</a></li>
<li><a href="#Angular-momentum-_0028j_002cm_0029_002dkets-and-bras" accesskey="2">Angular momentum (j,m)-kets and bras</a></li>
<li><a href="#Addition-of-angular-momentum-in-the-_0028j_002cm_0029_002drepresentation" accesskey="3">Addition of angular momentum in the (j,m)-representation</a></li>
<li><a href="#Example-computations" accesskey="4">Example computations</a></li>
</ul>
<div class="subsection-level-extent" id="Matrix-representation-of-_0028j_002cm_0029_002dkets-and-bras">
<h4 class="subsection"><span>1.3.1 Matrix representation of (j,m)-kets and bras<a class="copiable-link" href="#Matrix-representation-of-_0028j_002cm_0029_002dkets-and-bras"> &para;</a></span></h4>

<p>The matrix representation of kets and bras in the <code class="code">qm</code> package are
represented in the <code class="code">z</code>-basis. To create a matrix representation of
of a ket or bra in the (j,m)-basis one uses the <code class="code">spin_mket</code> and
<code class="code">spin_mbra</code> functions.
</p>
<a class="anchor" id="spin_005fmket"></a><dl class="first-deffn">
<dt class="deffn" id="index-spin_005fmket"><span class="category-def">Function: </span><span><strong class="def-name">spin_mket</strong> <var class="def-var-arguments">(s,m<sub class="sub">s</sub>,[1,2])</var><a class="copiable-link" href="#index-spin_005fmket"> &para;</a></span></dt>
<dd><p><code class="code">spin_mket</code> returns a ket in the <code class="code">z</code>-basis for spin <code class="code">s</code>
and z-projection <code class="code">m<sub class="sub">s</sub></code>, for axis 1=X or 2=Y.
</p></dd></dl>

<a class="anchor" id="spin_005fmbra"></a><dl class="first-deffn">
<dt class="deffn" id="index-spin_005fmbra"><span class="category-def">Function: </span><span><strong class="def-name">spin_mbra</strong> <var class="def-var-arguments">(s,m<sub class="sub">s</sub>,[1,2])</var><a class="copiable-link" href="#index-spin_005fmbra"> &para;</a></span></dt>
<dd><p><code class="code">spin_mbra</code> returns a bra in the <code class="code">z</code>-basis for spin <code class="code">s</code>
and z-projection <code class="code">m<sub class="sub">s</sub></code>, for axis 1=X or 2=Y.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) spin_mbra(3/2,1/2,2);
                    [ sqrt(3)     %i    1      sqrt(3) %i ]
(%o1)               [ -------  - ----  ----  - ---------- ]
                    [   3/2       3/2   3/2        3/2    ]
                    [  2         2     2          2       ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-_0028j_002cm_0029_002dkets-and-bras">
<h4 class="subsection"><span>1.3.2 Angular momentum (j,m)-kets and bras<a class="copiable-link" href="#Angular-momentum-_0028j_002cm_0029_002dkets-and-bras"> &para;</a></span></h4>

<p>To create kets and bras in the <var class="var">|j,m&gt;</var> representation you use the
abstract <code class="code">ket</code> and <code class="code">bra</code> functions with <code class="code">j,m</code> as
arguments, as in <code class="code">ket([j,m])</code> and <code class="code">bra([j,m])</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) bra([3/2,1/2]);
                                     3  1
(%o1)                               &lt;-, -|
                                     2  2
(%i2) ket([3/2,1/2]);
                                     3  1
(%o2)                               |-, -&gt;
                                     2  2
</pre></div></div>

<p>Some convenience functions for making the kets are the following:
</p>
<a class="anchor" id="jmtop"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmtop"><span class="category-def">Function: </span><span><strong class="def-name">jmtop</strong> <var class="def-var-arguments">(<code class="code">j</code>)</var><a class="copiable-link" href="#index-jmtop"> &para;</a></span></dt>
<dd><p><code class="code">jmtop</code> creates a (j,m)-ket with <code class="code">m=j</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmtop(3/2);
                                     3  3
(%o1)                               |-, -&gt;
                                     2  2
</pre></div></div>

<a class="anchor" id="jmbot"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmbot"><span class="category-def">Function: </span><span><strong class="def-name">jmbot</strong> <var class="def-var-arguments">(<code class="code">j</code>)</var><a class="copiable-link" href="#index-jmbot"> &para;</a></span></dt>
<dd><p><code class="code">jmbot</code> creates a (j,m)-ket with <code class="code">m=-j</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmbot(3/2);
                                    3    3
(%o1)                              |-, - -&gt;
                                    2    2
</pre></div></div>

<a class="anchor" id="jmket"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmket"><span class="category-def">Function: </span><span><strong class="def-name">jmket</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jmket"> &para;</a></span></dt>
<dd><p><code class="code">jmket</code> creates a (j,m)-ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmket(3/2,1/2);
                                     3  1
(%o1)                               |-, -&gt;
                                     2  2
</pre></div></div>

<a class="anchor" id="jmketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmketp"><span class="category-def">Function: </span><span><strong class="def-name">jmketp</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-jmketp"> &para;</a></span></dt>
<dd><p><code class="code">jmketp</code> checks to see that the ket has an <code class="code">m</code>-value that is in
the set <code class="code">{-j,-j+1,&hellip;,+j}</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmketp(ket([j,m]));
(%o1)                                false
(%i2) jmketp(ket([3/2,1/2]));
(%o2)                                true
</pre></div></div>

<a class="anchor" id="jmbrap"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmbrap"><span class="category-def">Function: </span><span><strong class="def-name">jmbrap</strong> <var class="def-var-arguments">(<em class="emph">jmbra</em>)</var><a class="copiable-link" href="#index-jmbrap"> &para;</a></span></dt>
<dd><p><code class="code">jmbrap</code> checks to see that the bra has an <code class="code">m</code>-value that is in
the set <code class="code">{-j,-j+1,&hellip;,+j}</code>.
</p></dd></dl>

<a class="anchor" id="jmcheck"></a><dl class="first-deffn">
<dt class="deffn" id="index-jmcheck"><span class="category-def">Function: </span><span><strong class="def-name">jmcheck</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jmcheck"> &para;</a></span></dt>
<dd><p><code class="code">jmcheck</code> checks to see that <var class="var">m</var> is one of {-j, &hellip;, +j}.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jmcheck(3/2,1/2);
(%o1)                                true
</pre></div></div>

<a class="anchor" id="Jp"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jp"><span class="category-def">Function: </span><span><strong class="def-name">Jp</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jp"> &para;</a></span></dt>
<dd><p><code class="code">Jp</code> is the <code class="code">J<sub class="sub">+</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m+1))*hbar*jmket(j,m+1)</code>.
</p></dd></dl>

<a class="anchor" id="Jm"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jm"><span class="category-def">Function: </span><span><strong class="def-name">Jm</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jm"> &para;</a></span></dt>
<dd><p><code class="code">Jm</code> is the <code class="code">J<sub class="sub">-</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m-1))*hbar*jmket(j,m-1)</code>.
</p></dd></dl>

<a class="anchor" id="Jsqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jsqr"><span class="category-def">Function: </span><span><strong class="def-name">Jsqr</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jsqr"> &para;</a></span></dt>
<dd><p><code class="code">Jsqr</code> is the <code class="code">J<sup class="sup">2</sup></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">j*(j+1)*hbar<sup class="sup">2</sup>*jmket(j,m)</code>.
</p></dd></dl>

<a class="anchor" id="Jz"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jz"><span class="category-def">Function: </span><span><strong class="def-name">Jz</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jz"> &para;</a></span></dt>
<dd><p><code class="code">Jz</code> is the <code class="code">J<sub class="sub">z</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jmket(j,m)</code> and returns <code class="code">m*hbar*jmket(j,m)</code>.
</p></dd></dl>

<p>These functions are illustrated below.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:ket([j,m]);
(%o1)                               |j, m&gt;
(%i2) Jp(k);
(%o2)             hbar |j, m + 1&gt; sqrt(j (j + 1) - m (m + 1))
(%i3) Jm(k);
(%o3)             hbar |j, m - 1&gt; sqrt(j (j + 1) - (m - 1) m)
(%i4) Jsqr(k);
                                2
(%o4)                       hbar  j (j + 1) |j, m&gt;
(%i5) Jz(k);
(%o5)                            hbar |j, m&gt; m
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Addition-of-angular-momentum-in-the-_0028j_002cm_0029_002drepresentation">
<h4 class="subsection"><span>1.3.3 Addition of angular momentum in the (j,m)-representation<a class="copiable-link" href="#Addition-of-angular-momentum-in-the-_0028j_002cm_0029_002drepresentation"> &para;</a></span></h4>

<p>Addition of angular momentum calculations can be performed in the
(j,m)-representation using the function definitions below. The internal
representation of kets and bras for this purpose is the following. Given
kets <code class="code">|j1,m1&gt;</code> and <code class="code">|j2,m2&gt;</code> a tensor product of (j,m)-kets
is instantiated as:
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">tpket(1,|j1,m1&gt;,|j2,m2&gt;)</code>
</p>
<p>and the corresponding bra is instantiated as:
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">tpbra(1,&lt;j1,m1|,&lt;j2,m2|)</code>
</p>
<p>where the factor of 1 is the multiplicative factor of the tensor
product. We call this the <em class="emph">common factor</em> (cf) of the tensor
product. The general form of a tensor product in the (j,m)
representation is:
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code class="code">tpket( cf, |j1,m1&gt;, |j2,m2&gt; )</code>.
</p>
<a class="anchor" id="tpket"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpket"><span class="category-def">Function: </span><span><strong class="def-name">tpket</strong> <var class="def-var-arguments">(<em class="emph">jmket1,jmket2</em>)</var><a class="copiable-link" href="#index-tpket"> &para;</a></span></dt>
<dd><p><code class="code">tpket</code> instantiates a tensor product of two (j,m)-kets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tpket(ket([3/2,1/2]),ket([1/2,1/2]));
                                     3  1    1  1
(%o1)                      tpket(1, |-, -&gt;, |-, -&gt;)
                                     2  2    2  2
</pre></div></div>

<a class="anchor" id="tpbra"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpbra"><span class="category-def">Function: </span><span><strong class="def-name">tpbra</strong> <var class="def-var-arguments">(<em class="emph">jmbra1,jmbra2</em>)</var><a class="copiable-link" href="#index-tpbra"> &para;</a></span></dt>
<dd><p><code class="code">tpbra</code> instantiates a tensor product of two (j,m)-bras.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) tpbra(bra([3/2,1/2]),bra([1/2,1/2]));
                                     3  1    1  1
(%o1)                      tpbra(1, &lt;-, -|, &lt;-, -|)
                                     2  2    2  2
</pre></div></div>

<a class="anchor" id="tpbraket"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpbraket"><span class="category-def">Function: </span><span><strong class="def-name">tpbraket</strong> <var class="def-var-arguments">(<em class="emph">tpbra,tpket</em>)</var><a class="copiable-link" href="#index-tpbraket"> &para;</a></span></dt>
<dd><p><code class="code">tpbraket</code> returns the bracket of a <code class="code">tpbra</code> and a <code class="code">tpket</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(jmtop(1),jmbot(1));
(%o1)                     tpket(1, |1, 1&gt;, |1, - 1&gt;)
(%i2) K:Jtsqr(k);
                   2                                  2
(%o2)  tpket(2 hbar , |1, 1&gt;, |1, - 1&gt;) + tpket(2 hbar , |1, 0&gt;, |1, 0&gt;)
(%i3) B:tpdagger(k);
(%o3)                     tpbra(1, &lt;1, 1|, &lt;1, - 1|)
(%i4) tpbraket(B,K);
                                          2
(%o4)                               2 hbar
</pre></div></div>

<a class="anchor" id="tpcfset"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpcfset"><span class="category-def">Function: </span><span><strong class="def-name">tpcfset</strong> <var class="def-var-arguments">(<code class="code">cf</code>,<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-tpcfset"> &para;</a></span></dt>
<dd><p><code class="code">tpcfset</code> manually sets the <em class="emph">common factor</em> <code class="code">cf</code> of a <code class="code">tpket</code>.
</p></dd></dl>

<a class="anchor" id="tpscmult"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpscmult"><span class="category-def">Function: </span><span><strong class="def-name">tpscmult</strong> <var class="def-var-arguments">(<code class="code">a</code>,<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-tpscmult"> &para;</a></span></dt>
<dd><p><code class="code">tpscmult</code> multiplies the tensor product&rsquo;s common factor by <code class="code">a</code>.
Any symbols must be <code class="code">declare</code>d <code class="code">scalar</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                    1  1    1    1
(%o1)                     tpket(1, |-, -&gt;, |-, - -&gt;)
                                    2  2    2    2
(%i2) declare(c,scalar);
(%o2)                                done
(%i3) tpscmult(c,k1);
                                    1  1    1    1
(%o3)                     tpket(c, |-, -&gt;, |-, - -&gt;)
                                    2  2    2    2
</pre></div></div>

<a class="anchor" id="tpadd"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpadd"><span class="category-def">Function: </span><span><strong class="def-name">tpadd</strong> <var class="def-var-arguments">(<em class="emph">tpket,tpket</em>)</var><a class="copiable-link" href="#index-tpadd"> &para;</a></span></dt>
<dd><p><code class="code">tpadd</code> adds two <code class="code">tpket</code>s. This function is necessary
to avoid trouble with Maxima&rsquo;s automatic list arithmetic.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                    1  1    1    1
(%o1)                     tpket(1, |-, -&gt;, |-, - -&gt;)
                                    2  2    2    2
(%i2) k2:tpket(ket([1/2,-1/2]),ket([1/2,1/2]));
                                    1    1    1  1
(%o2)                     tpket(1, |-, - -&gt;, |-, -&gt;)
                                    2    2    2  2
(%i3) tpadd(k1,k2);
                      1  1    1    1               1    1    1  1
(%o3)       tpket(1, |-, -&gt;, |-, - -&gt;) + tpket(1, |-, - -&gt;, |-, -&gt;)
                      2  2    2    2               2    2    2  2
</pre></div></div>

<a class="anchor" id="tpdagger"></a><dl class="first-deffn">
<dt class="deffn" id="index-tpdagger"><span class="category-def">Function: </span><span><strong class="def-name">tpdagger</strong> <var class="def-var-arguments">(<em class="emph">tpket or tpbra</em>)</var><a class="copiable-link" href="#index-tpdagger"> &para;</a></span></dt>
<dd><p><code class="code">tpdagger</code> takes the quantum mechanical dagger of a <code class="code">tpket</code> or <code class="code">tpbra</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k1:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                    1  1    1    1
(%o1)                     tpket(1, |-, -&gt;, |-, - -&gt;)
                                    2  2    2    2
(%i2) tpdagger(k1);
                                    1  1    1    1
(%o2)                     tpbra(1, &lt;-, -|, &lt;-, - -|)
                                    2  2    2    2
</pre></div></div>

<a class="anchor" id="J1z"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1z"><span class="category-def">Function: </span><span><strong class="def-name">J1z</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1z"> &para;</a></span></dt>
<dd><p><code class="code">J1z</code> returns the tensor product of a tpket with <code class="code">Jz</code> acting
on the first ket.
</p></dd></dl>

<a class="anchor" id="J2z"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2z"><span class="category-def">Function: </span><span><strong class="def-name">J2z</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2z"> &para;</a></span></dt>
<dd><p><code class="code">J2z</code> returns the tensor product of a tpket with <code class="code">Jz</code> acting
on the second ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,3/2]),ket([1/2,1/2]));
                                     3  3    1  1
(%o1)                      tpket(1, |-, -&gt;, |-, -&gt;)
                                     2  2    2  2
(%i2) J1z(k);
                               3 hbar   3  3    1  1
(%o2)                    tpket(------, |-, -&gt;, |-, -&gt;)
                                 2      2  2    2  2
(%i3) J2z(k);
                                hbar   3  3    1  1
(%o3)                     tpket(----, |-, -&gt;, |-, -&gt;)
                                 2     2  2    2  2
</pre></div></div>

<a class="anchor" id="Jtz"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtz"><span class="category-def">Function: </span><span><strong class="def-name">Jtz</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtz"> &para;</a></span></dt>
<dd><p><code class="code">Jtz</code> is the total z-projection of spin operator acting on a tpket
and returning <code class="code">(J<sub class="sub">1z</sub>+J<sub class="sub">2z</sub>)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,3/2]),ket([1/2,1/2]));
                                     3  3    1  1
(%o1)                      tpket(1, |-, -&gt;, |-, -&gt;)
                                     2  2    2  2
(%i2) Jtz(k);
                                        3  3    1  1
(%o2)                    tpket(2 hbar, |-, -&gt;, |-, -&gt;)
                                        2  2    2  2
</pre></div></div>

<a class="anchor" id="J1sqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1sqr"><span class="category-def">Function: </span><span><strong class="def-name">J1sqr</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1sqr"> &para;</a></span></dt>
<dd><p><code class="code">J1sqr</code> returns <code class="code">Jsqr</code> for the first ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J2sqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2sqr"><span class="category-def">Function: </span><span><strong class="def-name">J2sqr</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2sqr"> &para;</a></span></dt>
<dd><p><code class="code">J2sqr</code> returns <code class="code">Jsqr</code> for the second ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J1p"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1p"><span class="category-def">Function: </span><span><strong class="def-name">J1p</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1p"> &para;</a></span></dt>
<dd><p><code class="code">J1p</code> returns <code class="code">J<sub class="sub">+</sub></code> for the first ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J2p"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2p"><span class="category-def">Function: </span><span><strong class="def-name">J2p</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2p"> &para;</a></span></dt>
<dd><p><code class="code">J2p</code> returns <code class="code">J<sub class="sub">+</sub></code> for the second ket of a tpket.
</p></dd></dl>

<a class="anchor" id="Jtp"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtp"><span class="category-def">Function: </span><span><strong class="def-name">Jtp</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtp"> &para;</a></span></dt>
<dd><p><code class="code">Jtp</code> returns <code class="code">(J<sub class="sub">1+</sub>+J<sub class="sub">2+</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="J1m"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1m"><span class="category-def">Function: </span><span><strong class="def-name">J1m</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1m"> &para;</a></span></dt>
<dd><p><code class="code">J1m</code> returns <code class="code">J<sub class="sub">-</sub></code> for the first ket of a tpket.
</p></dd></dl>

<a class="anchor" id="J2m"></a><dl class="first-deffn">
<dt class="deffn" id="index-J2m"><span class="category-def">Function: </span><span><strong class="def-name">J2m</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J2m"> &para;</a></span></dt>
<dd><p><code class="code">J2m</code> returns <code class="code">J<sub class="sub">-</sub></code> for the second ket of a tpket.
</p></dd></dl>

<a class="anchor" id="Jtm"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtm"><span class="category-def">Function: </span><span><strong class="def-name">Jtm</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtm"> &para;</a></span></dt>
<dd><p><code class="code">Jtm</code> returns <code class="code">(J<sub class="sub">1-</sub>+J<sub class="sub">2-</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="J1p2m"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1p2m"><span class="category-def">Function: </span><span><strong class="def-name">J1p2m</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1p2m"> &para;</a></span></dt>
<dd><p><code class="code">J1p2m</code> returns <code class="code">(J<sub class="sub">1+</sub>J<sub class="sub">2-</sub>)</code> for the tpket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,1/2]),ket([1/2,1/2]));
                                     3  1    1  1
(%o1)                      tpket(1, |-, -&gt;, |-, -&gt;)
                                     2  2    2  2
(%i2) b:tpdagger(k);
                                     3  1    1  1
(%o2)                      tpbra(1, &lt;-, -|, &lt;-, -|)
                                     2  2    2  2
(%i3) J1p2m(k);
                                      2   3  3    1    1
(%o3)               tpket(sqrt(3) hbar , |-, -&gt;, |-, - -&gt;)
                                          2  2    2    2
(%i4) J1m2p(k);
(%o4)                                  0
</pre></div></div>

<a class="anchor" id="J1m2p"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1m2p"><span class="category-def">Function: </span><span><strong class="def-name">J1m2p</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1m2p"> &para;</a></span></dt>
<dd><p><code class="code">J1m2p</code> returns <code class="code">(J<sub class="sub">1-</sub>J<sub class="sub">2+</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="J1zJ2z"></a><dl class="first-deffn">
<dt class="deffn" id="index-J1zJ2z"><span class="category-def">Function: </span><span><strong class="def-name">J1zJ2z</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-J1zJ2z"> &para;</a></span></dt>
<dd><p><code class="code">J1zJ2z</code> returns <code class="code">(J<sub class="sub">1z</sub>J<sub class="sub">2z</sub>)</code> for the tpket.
</p></dd></dl>

<a class="anchor" id="Jtsqr"></a><dl class="first-deffn">
<dt class="deffn" id="index-Jtsqr"><span class="category-def">Function: </span><span><strong class="def-name">Jtsqr</strong> <var class="def-var-arguments">(<em class="emph">tpket</em>)</var><a class="copiable-link" href="#index-Jtsqr"> &para;</a></span></dt>
<dd><p><code class="code">Jtsqr</code> returns <code class="code">(J<sub class="sub">1</sub><sup class="sup">2</sup>+J<sub class="sub">2</sub><sup class="sup">2</sup>+
J<sub class="sub">1+</sub>J<sub class="sub">2-</sub>+J<sub class="sub">1-</sub>J<sub class="sub">2+</sub>+J<sub class="sub">1z</sub>J<sub class="sub">2z</sub>)</code> for the
tpket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(ket([3/2,-1/2]),ket([1/2,1/2]));
                                    3    1    1  1
(%o1)                     tpket(1, |-, - -&gt;, |-, -&gt;)
                                    2    2    2  2
(%i2) B:tpdagger(k);
                                    3    1    1  1
(%o2)                     tpbra(1, &lt;-, - -|, &lt;-, -|)
                                    2    2    2  2
(%i3) K2:Jtsqr(k);
                  2   3    1    1  1                 2   3  1    1    1
(%o3) tpket(4 hbar , |-, - -&gt;, |-, -&gt;) + tpket(2 hbar , |-, -&gt;, |-, - -&gt;)
                      2    2    2  2                     2  2    2    2
(%i4) tpbraket(B,K2);
                                          2
(%o4)                               4 hbar
</pre></div></div>

<a class="anchor" id="get_005fj"></a><dl class="first-deffn">
<dt class="deffn" id="index-get_005fj"><span class="category-def">Function: </span><span><strong class="def-name">get_j</strong> <var class="def-var-arguments">(<code class="code">q</code>)</var><a class="copiable-link" href="#index-get_005fj"> &para;</a></span></dt>
<dd><p><code class="code">get_j</code> is a convenience function that computes <code class="code">j</code> from
<code class="code">j(j+1)=q</code> where <code class="code">q</code> is a rational number. This function is
useful after using the function <code class="code">Jtsqr</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) get_j(15/4);
                                         3
(%o1)                                j = -
                                         2
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Example-computations">
<h4 class="subsection"><span>1.3.4 Example computations<a class="copiable-link" href="#Example-computations"> &para;</a></span></h4>

<p>For the first example, let us see how to determine the total spin state
<code class="code">|j,m&gt;</code> of the two-particle state <code class="code">|1/2,1/2;1,1&gt;</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(jmtop(1/2),jmtop(1));
                                     1  1
(%o1)                      tpket(1, |-, -&gt;, |1, 1&gt;)
                                     2  2
(%i2) Jtsqr(k);
                                     2
                              15 hbar    1  1
(%o2)                   tpket(--------, |-, -&gt;, |1, 1&gt;)
                                 4       2  2
(%i3) get_j(15/4);
                                         3
(%o3)                                j = -
                                         2
</pre></div></div>

<p>This is an eigenket of <code class="code">Jtsqr</code>, thus <code class="code">|3/2,3/2&gt; =
|1/2,1/2;1,1&gt;</code>, and it is also the top state. One can now apply the
lowering operator to find the other states: <code class="code">|3/2,1/2&gt;</code>,
<code class="code">|3/2,-1/2&gt;</code>, and <code class="code">|3/2,-3/2&gt;</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:tpket(jmtop(1/2),jmtop(1));
                                     1  1
(%o1)                      tpket(1, |-, -&gt;, |1, 1&gt;)
                                     2  2
(%i2) k2:Jtm(k);
                           1  1                          1    1
(%o2) tpket(sqrt(2) hbar, |-, -&gt;, |1, 0&gt;) + tpket(hbar, |-, - -&gt;, |1, 1&gt;)
                           2  2                          2    2
(%i3) k3:Jtm(k2);
             3/2     2   1    1                         2   1  1
(%o3) tpket(2    hbar , |-, - -&gt;, |1, 0&gt;) + tpket(2 hbar , |-, -&gt;, |1, - 1&gt;)
                         2    2                             2  2
(%i4) k4:Jtm(k3);
                  3   1    1                           3   1    1
(%o4) tpket(4 hbar , |-, - -&gt;, |1, - 1&gt;) + tpket(2 hbar , |-, - -&gt;, |1, - 1&gt;)
                      2    2                               2    2
</pre></div></div>


<p>In the example below we calculate the Clebsch-Gordan coefficients of the
two-particle state with two spin-1/2 particles. We begin by defining the
top rung of the ladder and stepping down. To calculate the coefficients
one first creates the tensor product top state, and computes the values
for the total angular momentum <code class="code">|J,M&gt;</code>. At the top of the ladder
<code class="code">M=J</code>. For the first step down the ladder one computes <code class="code">Jm
|J,M&gt;</code>, which must be equal to <code class="code">Jtm |j1,m1;j2,m2&gt;</code>. This gives
first set of coefficients and one continues down the ladder to compute
the rest of them.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) top:tpket(jmtop(1/2),jmtop(1/2));
                                     1  1    1  1
(%o1)                      tpket(1, |-, -&gt;, |-, -&gt;)
                                     2  2    2  2
(%i2) Jtsqr(top);
                                    2   1  1    1  1
(%o2)                   tpket(2 hbar , |-, -&gt;, |-, -&gt;)
                                        2  2    2  2
(%i3) get_j(2);
(%o3)                                j = 1
(%i4) Jtz(top);
                                       1  1    1  1
(%o4)                     tpket(hbar, |-, -&gt;, |-, -&gt;)
                                       2  2    2  2
(%i5) JMtop:ket([1,1]);
(%o5)                               |1, 1&gt;
(%i6) mid:Jtm(top);
                      1  1    1    1                  1    1    1  1
(%o6)    tpket(hbar, |-, -&gt;, |-, - -&gt;) + tpket(hbar, |-, - -&gt;, |-, -&gt;)
                      2  2    2    2                  2    2    2  2
(%i7) Jm(JMtop);
(%o7)                         sqrt(2) |1, 0&gt; hbar
(%i8) mid:tpscmult(1/(sqrt(2)*hbar),mid);
               1      1  1    1    1              1      1    1    1  1
(%o8) tpket(-------, |-, -&gt;, |-, - -&gt;) + tpket(-------, |-, - -&gt;, |-, -&gt;)
            sqrt(2)   2  2    2    2           sqrt(2)   2    2    2  2
(%i9) bot:Jtm(mid);
                                         1    1    1    1
(%o9)               tpket(sqrt(2) hbar, |-, - -&gt;, |-, - -&gt;)
                                         2    2    2    2
(%i10) Jm(ket([1,0]));
(%o10)                       sqrt(2) |1, - 1&gt; hbar
(%i11) bot:tpscmult(1/(sqrt(2)*hbar),bot);
                                   1    1    1    1
(%o11)                   tpket(1, |-, - -&gt;, |-, - -&gt;)
                                   2    2    2    2
</pre></div></div>

</div>
</div>
<div class="section-level-extent" id="General-tensor-products">
<h3 class="section"><span>1.4 General tensor products<a class="copiable-link" href="#General-tensor-products"> &para;</a></span></h3>

<p>Tensor products are represented as lists in the <code class="code">qm</code> package. The
ket tensor product <code class="code">|z+,z+&gt;</code> can be represented as
<code class="code">ket([u,d])</code>, for example, and the bra tensor product <code class="code">&lt;a,b|</code>
is represented as <code class="code">bra([a,b])</code> for states <code class="code">a</code> and
<code class="code">b</code>. For a tensor product where the identity is one of the elements
of the product, substitute the string <code class="code">Id</code> in the ket or bra at the
desired location. See the examples below for the use of the identity in
tensor products.
</p>
<p>Examples below show how to create abstract tensor products that contain
the identity element <code class="code">Id</code> and how to take the bracket of these
tensor products.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) K:ket([a1,b1]);
(%o1)                              |a1, b1&gt;
(%i2) B:bra([a2,b2]);
(%o2)                              &lt;a2, b2|
(%i3) braket(B,K);
(%o3)                kron_delta(a1, a2) kron_delta(b1, b2)
</pre></div><div class="group"><pre class="example-preformatted">(%i1) bra([a1,Id,c1]) . ket([a2,b2,c2]);
(%o1)          |-, b2, -&gt; kron_delta(a1, a2) kron_delta(c1, c2)
(%i2) bra([a1,b1,c1]) . ket([Id,b2,c2]);
(%o2)          &lt;a1, -, -| kron_delta(b1, b2) kron_delta(c1, c2)
</pre></div></div>

<p>In the next example we construct the state function for an entangled
Bell pair, construct the density matrix, and then trace over the first
particle to obtain the density submatrix for particle 2.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) bell:(1/sqrt(2))*(ket([u,d])-ket([d,u]));
                                |u, d&gt; - |d, u&gt;
(%o1)                           ---------------
                                    sqrt(2)
(%i2) rho:bell . dagger(bell);
      |u, d&gt; . &lt;u, d| - |u, d&gt; . &lt;d, u| - |d, u&gt; . &lt;u, d| + |d, u&gt; . &lt;d, u|
(%o2) ---------------------------------------------------------------------
                                        2
(%i3) assume(not equal(u,d));
(%o3)                          [notequal(u, d)]
(%i4) trace1:bra([u,Id]) . rho . ket([u,Id])+bra([d,Id]) . rho . ket([d,Id]);
                       |-, u&gt; . &lt;-, u|   |-, d&gt; . &lt;-, d|
(%o4)                  --------------- + ---------------
                              2                 2
</pre></div></div>

<p>One can also construct the density matrix using the function <code class="code">matrep</code>.
</p>
<a class="anchor" id="matrep"></a><dl class="first-deffn">
<dt class="deffn" id="index-matrep"><span class="category-def">Function: </span><span><strong class="def-name">matrep</strong> <var class="def-var-arguments">(<code class="code">A,B</code>)</var><a class="copiable-link" href="#index-matrep"> &para;</a></span></dt>
<dd><p>Given an abstract representation of an operator, e.g.  <code class="code">A = |a&gt;
. &lt;b| + |b&gt; . &lt;a|</code>, the function <code class="code">matrep</code> takes the operator
<code class="code">A</code> and basis set <code class="code">B</code> and constructs the matrix representation
of <code class="code">A</code>. NOTE: if there are symbolic constants as coefficients in
the abstract representation they must be <code class="code">declared</code>d as scalar for
the simplification rules to work properly with the non-commutative &ldquo;.&rdquo;
operator.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) bell:(1/sqrt(2))*(ket([1,0])-ket([0,1]));
                                |1, 0&gt; - |0, 1&gt;
(%o1)                           ---------------
                                    sqrt(2)
(%i2) rho:bell . dagger(bell);
      |1, 0&gt; . &lt;1, 0| - |1, 0&gt; . &lt;0, 1| - |0, 1&gt; . &lt;1, 0| + |0, 1&gt; . &lt;0, 1|
(%o2) ---------------------------------------------------------------------
                                        2
(%i3) B:[ket([1,1]),ket([1,0]),ket([0,1]),ket([0,0])];
(%o3)                  [|1, 1&gt;, |1, 0&gt;, |0, 1&gt;, |0, 0&gt;]
(%i4) matrep(rho,B);
                              [ 0   0    0   0 ]
                              [                ]
                              [     1     1    ]
                              [ 0   -   - -  0 ]
                              [     2     2    ]
(%o4)                         [                ]
                              [      1   1     ]
                              [ 0  - -   -   0 ]
                              [      2   2     ]
                              [                ]
                              [ 0   0    0   0 ]
(%i5) declare([a,b],scalar);
(%o5)                                done
(%i6) O:a*ket([1]) . bra([0])+b*ket([0]) . bra([1]);
(%o6)                    (|0&gt; . &lt;1|) b + (|1&gt; . &lt;0|) a
(%i7) B:[ket([1]),ket([0])];
(%o7)                             [|1&gt;, |0&gt;]
(%i8) matrep(O,B);
                                   [ 0  a ]
(%o8)                              [      ]
                                   [ b  0 ]
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Abstract-basis-set-generator" accesskey="1">Abstract basis set generator</a></li>
<li><a href="#Example-calculation-of-matrix-elements" accesskey="2">Example calculation of matrix elements</a></li>
<li><a href="#Stationary-states-from-a-Hamiltonian" accesskey="3">Stationary states from a Hamiltonian</a></li>
<li><a href="#Matrix-trace-functions" accesskey="4">Matrix trace functions</a></li>
</ul>
<div class="subsection-level-extent" id="Abstract-basis-set-generator">
<h4 class="subsection"><span>1.4.1 Abstract basis set generator<a class="copiable-link" href="#Abstract-basis-set-generator"> &para;</a></span></h4>

<a class="anchor" id="basis_005fset"></a><dl class="first-deffn">
<dt class="deffn" id="index-basis_005fset"><span class="category-def">Function: </span><span><strong class="def-name">basis_set</strong> <var class="def-var-arguments">(<code class="code">n,[l<sub class="sub">1</sub>,l<sub class="sub">2</sub>,&hellip;]</code>)</var><a class="copiable-link" href="#index-basis_005fset"> &para;</a></span></dt>
<dd><p>The function <code class="code">basis_set</code> takes two arguments, <code class="code">n</code> is the
number of particles, and the second argument is a list of labels of the
particle states. The number of elements in the basis set is
<code class="code">m<sup class="sup">n</sup></code>, where <code class="code">m</code> is the number of states per particle.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) basis_set(2,[0,1]);
(%o1)                  [|1, 1&gt;, |1, 0&gt;, |0, 1&gt;, |0, 0&gt;]
(%i2) basis_set(3,[u,d]);
(%o2) [|d, d, d&gt;, |d, d, u&gt;, |d, u, d&gt;, |d, u, u&gt;, |u, d, d&gt;, |u, d, u&gt;, 
                                                          |u, u, d&gt;, |u, u, u&gt;]
</pre></div></div>

<a class="anchor" id="complete"></a><dl class="first-deffn">
<dt class="deffn" id="index-complete"><span class="category-def">Function: </span><span><strong class="def-name">complete</strong> <var class="def-var-arguments">(<code class="code">B</code>)</var><a class="copiable-link" href="#index-complete"> &para;</a></span></dt>
<dd><p>The function <code class="code">complete</code> generates the completeness relation
for the basis set <code class="code">B</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) B:basis_set(1,[0,1]);
(%o1)                             [|1&gt;, |0&gt;]
(%i2) complete(B);
(%o2)                        |1&gt; . &lt;1| + |0&gt; . &lt;0|
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Example-calculation-of-matrix-elements">
<h4 class="subsection"><span>1.4.2 Example calculation of matrix elements<a class="copiable-link" href="#Example-calculation-of-matrix-elements"> &para;</a></span></h4>

<p>Let us see how to compute the matrix elements of the operator
<code class="code">(J1z-J1z)</code> in the z-basis for two spin-1/2 particles.  First, we
define the four basis kets of the form
<code class="code">|j<sub class="sub">1</sub>,m<sub class="sub">1</sub>;j<sub class="sub">2</sub>,m<sub class="sub">2</sub>&gt;</code>. Next we define the
Hamiltonian and then use the function <code class="code">matrep</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) b1:tpket(ket([1/2,1/2]),ket([1/2,1/2]));
                                     1  1    1  1
(%o1)                      tpket(1, |-, -&gt;, |-, -&gt;)
                                     2  2    2  2
(%i2) b2:tpket(ket([1/2,1/2]),ket([1/2,-1/2]));
                                    1  1    1    1
(%o2)                     tpket(1, |-, -&gt;, |-, - -&gt;)
                                    2  2    2    2
(%i3) b3:tpket(ket([1/2,-1/2]),ket([1/2,1/2]));
                                    1    1    1  1
(%o3)                     tpket(1, |-, - -&gt;, |-, -&gt;)
                                    2    2    2  2
(%i4) b4:tpket(ket([1/2,-1/2]),ket([1/2,-1/2]));
                                   1    1    1    1
(%o4)                    tpket(1, |-, - -&gt;, |-, - -&gt;)
                                   2    2    2    2
(%i5) B:[b1,b2,b3,b4];
                 1  1    1  1              1  1    1    1
(%o5) [tpket(1, |-, -&gt;, |-, -&gt;), tpket(1, |-, -&gt;, |-, - -&gt;), 
                 2  2    2  2              2  2    2    2
                                1    1    1  1              1    1    1    1
                      tpket(1, |-, - -&gt;, |-, -&gt;), tpket(1, |-, - -&gt;, |-, - -&gt;)]
                                2    2    2  2              2    2    2    2
(%i6) H:omega*(J1z-J2z);
(%o6)                          (J1z - J2z) omega
(%i7) declare(omega,scalar);
(%o7)                                done
(%i8) matrep(H,B);
                      [ 0      0            0        0 ]
                      [                                ]
                      [ 0  hbar omega       0        0 ]
(%o8)                 [                                ]
                      [ 0      0       - hbar omega  0 ]
                      [                                ]
                      [ 0      0            0        0 ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Stationary-states-from-a-Hamiltonian">
<h4 class="subsection"><span>1.4.3 Stationary states from a Hamiltonian<a class="copiable-link" href="#Stationary-states-from-a-Hamiltonian"> &para;</a></span></h4>

<a class="anchor" id="stationary"></a><dl class="first-deffn">
<dt class="deffn" id="index-stationary"><span class="category-def">Function: </span><span><strong class="def-name">stationary</strong> <var class="def-var-arguments">(<code class="code">evals,evecs,basis</code>)</var><a class="copiable-link" href="#index-stationary"> &para;</a></span></dt>
<dd><p>The function <code class="code">stationary</code> takes the output of the
<code class="code">eigenvectors</code> command and a basis set and constructs
the stationary states from the basis used to construct
the matrix representation of the Hamiltonian.
</p></dd></dl>

<p>Example:
</p>
<p>The hyperfine splitting in the hydrogen atom is due to the
spin-spin interaction of the electron and the proton. The
Hamiltonian is  2*A/hbar^2 * (S<sub class="sub">1</sub> &bull; S<sub class="sub">2</sub>). Let&rsquo;s calculate
the energy levels and the stationary states.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare(A,scalar);
(%o1)                                done
(%i2) H:(A/hbar^2)*(J1p2m+J1m2p+2*J1zJ2z);
                         A (2 J1zJ2z + J1p2m + J1m2p)
(%o2)                    ----------------------------
                                        2
                                    hbar
(%i3) Hmat:matrep(H,bj1212);
                              [ A              ]
                              [ -   0    0   0 ]
                              [ 2              ]
                              [                ]
                              [      A         ]
                              [ 0  - -   A   0 ]
                              [      2         ]
(%o3)                         [                ]
                              [           A    ]
                              [ 0   A   - -  0 ]
                              [           2    ]
                              [                ]
                              [              A ]
                              [ 0   0    0   - ]
                              [              2 ]
(%i4) [evals,evecs]:eigenvectors(Hmat);
           3 A  A
(%o4) [[[- ---, -], [1, 3]], [[[0, 1, - 1, 0]], 
            2   2
                                   [[1, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 1]]]]
(%i5) states:stationary(evals,evecs,bj1212);
                 1  1    1    1                 1    1    1  1
(%o5) [tpket(1, |-, -&gt;, |-, - -&gt;) + tpket(- 1, |-, - -&gt;, |-, -&gt;), 
                 2  2    2    2                 2    2    2  2
          1  1    1  1              1  1    1    1
tpket(1, |-, -&gt;, |-, -&gt;), tpket(1, |-, -&gt;, |-, - -&gt;)
          2  2    2  2              2  2    2    2
             1    1    1  1              1    1    1    1
 + tpket(1, |-, - -&gt;, |-, -&gt;), tpket(1, |-, - -&gt;, |-, - -&gt;)]
             2    2    2  2              2    2    2    2
(%i6) Jtz(states[1]);
(%o6)                                  0
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Matrix-trace-functions">
<h4 class="subsection"><span>1.4.4 Matrix trace functions<a class="copiable-link" href="#Matrix-trace-functions"> &para;</a></span></h4>

<a class="anchor" id="qm_005fmtrace"></a><dl class="first-deffn">
<dt class="deffn" id="index-qm_005fmtrace"><span class="category-def">Function: </span><span><strong class="def-name">qm_mtrace</strong> <var class="def-var-arguments">(<em class="emph">matrix</em>)</var><a class="copiable-link" href="#index-qm_005fmtrace"> &para;</a></span></dt>
<dd><p>The function <code class="code">qm_mtrace</code> is the usual matrix trace; it takes
a square matrix and returns the sum of the diagonal components.
</p></dd></dl>

<a class="anchor" id="qm_005fatrace"></a><dl class="first-deffn">
<dt class="deffn" id="index-qm_005fatrace"><span class="category-def">Function: </span><span><strong class="def-name">qm_atrace</strong> <var class="def-var-arguments">(<code class="code">A,B</code>)</var><a class="copiable-link" href="#index-qm_005fatrace"> &para;</a></span></dt>
<dd><p>The function <code class="code">qm_atrace</code> takes an abstract operator <code class="code">A</code> and a
basis <code class="code">B</code> and attempts to compute the matrix representation using
the <code class="code">matrep</code> function.  If successful it will return the matrix
trace of the resulting matrix.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) B:[ket([1]),ket([0])];
(%o1)                             [|1&gt;, |0&gt;]
(%i2) declare(c,scalar);
(%o2)                                done
(%i3) A:c*ket([1]) . bra([1]);
(%o3)                            (|1&gt; . &lt;1|) c
(%i4) matrep(A,B);
                                   [ c  0 ]
(%o4)                              [      ]
                                   [ 0  0 ]
(%i5) qm_atrace(A,B);
(%o5)                                  c
(%i6) bell:(1/sqrt(2))*(ket([1,0])-ket([0,1]));
                                |1, 0&gt; - |0, 1&gt;
(%o6)                           ---------------
                                    sqrt(2)
(%i7) rho:bell . dagger(bell);
      |1, 0&gt; . &lt;1, 0| - |1, 0&gt; . &lt;0, 1| - |0, 1&gt; . &lt;1, 0| + |0, 1&gt; . &lt;0, 1|
(%o7) ---------------------------------------------------------------------
                                        2
(%i8) trace1:bra([1,Id]) . rho . ket([1,Id])+bra([0,Id]) . rho . ket([0,Id]);
                       |-, 1&gt; . &lt;-, 1|   |-, 0&gt; . &lt;-, 0|
(%o8)                  --------------- + ---------------
                              2                 2
(%i9) B:[ket([Id,1]),ket([Id,0])];
(%o9)                         [|Id, 1&gt;, |Id, 0&gt;]
(%i10) matrep(trace1,B);
                                   [ 1    ]
                                   [ -  0 ]
                                   [ 2    ]
(%o10)                             [      ]
                                   [    1 ]
                                   [ 0  - ]
                                   [    2 ]
</pre></div></div>


</div>
</div>
<div class="section-level-extent" id="Quantum-harmonic-oscillator">
<h3 class="section"><span>1.5 Quantum harmonic oscillator<a class="copiable-link" href="#Quantum-harmonic-oscillator"> &para;</a></span></h3>

<p>The <code class="code">qm</code> package can perform simple quantum harmonic oscillator
calculations involving the ladder operators <code class="code">a<sup class="sup">+</sup></code> and
<code class="code">a<sup class="sup">-</sup></code>. These are referred to in the package as <code class="code">ap</code> and
<code class="code">am</code> respectively. For computations with arbitrary states to work
you must <code class="code">declare</code> the harmonic oscillator state, say <code class="code">n</code>, to
be both <code class="code">scalar</code> and <code class="code">integer</code>, as shown in the examples
below.
</p>
<a class="anchor" id="ap"></a><dl class="first-deffn">
<dt class="deffn" id="index-ap"><span class="category-def">Function: </span><span><strong class="def-name">ap</strong><a class="copiable-link" href="#index-ap"> &para;</a></span></dt>
<dd><p><code class="code">ap</code> is the raising operator <code class="code">a<sup class="sup">+</sup></code> for quantum harmonic
oscillator states.
</p></dd></dl>

<a class="anchor" id="am"></a><dl class="first-deffn">
<dt class="deffn" id="index-am"><span class="category-def">Function: </span><span><strong class="def-name">am</strong><a class="copiable-link" href="#index-am"> &para;</a></span></dt>
<dd><p><code class="code">a</code> is the lowering operator <code class="code">a<sup class="sup">-</sup></code> for quantum harmonic
oscillator states.
</p></dd></dl>

<p>A common problem is to compute the 1st order change in energy of a state
due to a perturbation of the harmonic potential, say an additional
factor <code class="code">V(x) = x^2 + g*x^4</code> for small <code class="code">g</code>. This example is
performed below, ignoring any physical constants in the problem.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare(n,integer,n,scalar);
(%o1)                                done
(%i2) ap . ket([n]);
(%o2)                         sqrt(n + 1) |n + 1&gt;
(%i3) am . ket([n]);
(%o3)                           |n - 1&gt; sqrt(n)
(%i4) bra([n]) . (ap+am)^^4 . ket([n]);
                                   2
(%o4)                           6 n  + 6 n + 3
</pre></div></div>

<br>
<p>Another package that handles quantum mechanical operators is
<code class="code">operator_algebra</code> written by Barton Willis.
</p>
</div>
<div class="section-level-extent" id="Pre_002ddefined-quantities">
<h3 class="section"><span>1.6 Pre-defined quantities<a class="copiable-link" href="#Pre_002ddefined-quantities"> &para;</a></span></h3>

<p>There are some pre-defined quantities in the file <code class="code">predef.mac</code>
that may be convenient for the user. These include Bell states, and 
some basis sets that are tedious to input.
</p>
<pre class="verbatim">bell1: 1/sqrt(2)*(ket([1,0])-ket([0,1]));
bell2: 1/sqrt(2)*(ket([1,0])+ket([0,1]));
bell3: 1/sqrt(2)*(ket([0,0])+ket([1,1]));
bell4: 1/sqrt(2)*(ket([0,0])-ket([1,1]));

ghz1: 1/sqrt(2)*(ket([0,0,0])-ket([1,1,1]));
ghz2: 1/sqrt(2)*(ket([0,0,0])+ket([1,1,1]));


/* pre-defined tpket bases */
bj1212: [ [tpket,1,ket([1/2,1/2]),ket([1/2,1/2])],
        [tpket,1,ket([1/2,1/2]),ket([1/2,-1/2])],
        [tpket,1,ket([1/2,-1/2]),ket([1/2,1/2])],
        [tpket,1,ket([1/2,-1/2]),ket([1/2,-1/2])] ];

bj112: [ [tpket,1,ket([1,1]),ket([1/2,1/2])],
         [tpket,1,ket([1,1]),ket([1/2,-1/2])],
         [tpket,1,ket([1,0]),ket([1/2,1/2])],
         [tpket,1,ket([1,0]),ket([1/2,-1/2])],         
         [tpket,1,ket([1,-1]),ket([1/2,1/2])],
         [tpket,1,ket([1,-1]),ket([1/2,-1/2])] ];

bj11:  [ [tpket,1,ket([1,1]),ket([1,1])],
         [tpket,1,ket([1,1]),ket([1,0])],
         [tpket,1,ket([1,1]),ket([1,-1])],
         [tpket,1,ket([1,0]),ket([1,1])],
         [tpket,1,ket([1,0]),ket([1,0])],
         [tpket,1,ket([1,0]),ket([1,-1])],         
         [tpket,1,ket([1,-1]),ket([1,1])],
         [tpket,1,ket([1,-1]),ket([1,0])],
         [tpket,1,ket([1,-1]),ket([1,-1])] ];
</pre>
</div>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
